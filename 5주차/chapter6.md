# 6장 단위 테스트 스타일

### 6.1 단위 테스트의 세가지 스타일
- 출력 기반 테스트
- 상태 기반 테스트
- 통신 기반 테스트

**출력 기반 테스트 정의**  
출력 기반 테스트는 대상 시스템에 입력을 넣고 생성되는 출력을 점검하는 방식이다.  
전역 상태나 내부상태를 변경하지 않는 코드에만 적용되므로 반환 값만 검증하면 된다.

**상태 기반 테스트 정의**  
작업이 완료된 후 시스템 상태를 확인하는 것이다.  
여기서 상태는 SUT나 협력자 중 하나, 또는 데이터베이스나 파일 시스템등과 같은 프로세스 외부 의존성의 상태 등을 의미할 수 있다.

**통신 기반 테스트 정의**  
목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다.

### 6.2 단위 테스트 스타일 비교
좋은 단위 테스트의 4대 요소와 단위 테스트 스타일 비교
(회귀 방지, 리팩터링 내성, 빠른 피드백, 유지 보수성)

**회귀방지와 피드백 속도 지표로 스타일 비교하기**  
테스트 스타일과의 상관관계가 거의 없다.

**리팩터링 내성 지표로 스타일 비교하기**
- 출력 기반 테스트 : 테스트가 테스트 대상 메서드에만 결합되므로 거짓 양성방지가 가장 우수
- 상태 기반 테스트 : 거짓 양성이 되기 쉽다. 테스트 대상 메서드외에도 클래스와 함께 작용하기 때문이다.
- 통신 기반 테스트 : 외부 의존성 때문에 허위 경보에 가장 취약하다.  

**유지보수성 지표로 스타일 비교하기**
테스트를 이해하기 얼마나 어려운가 / 테스트를 실행하기 얼마나 어려운가
이 두가지 특성으로 유지 보수성을 정의 한다.

- 출력 기반 테스트 : 가장 유지보수에 용이, 항상 짧고 간결하며 전역 상태나 내부 상태를 변경할 리 없고 외부 의존성을 다루지 않음.
- 상태 기반 테스트 : 출력 기반보다 더 많은 공간을 차지 하기 때문에 유지보수가 쉽지 않다.
```
    // 글의 상태 검증만 4줄, 상태 기반은 종종 더 많은 데이터를 확인하므로 크기가 커질 수 있다.
    Assert.Equal(1, sut.Comments.Count);
    Assert.Equal(text, sut.Comments[0].Text);
    Assert.Equal(author, sut.Comments[0].Author);
    Assert.Equal(now, sut.Comments[0].DateCreated);
```
```
// comment 사용, 코드 오염으로 이어질 수 있다. (11장에 자세히..)
public void Adding_a_comment_to_an_article()
        {
            var sut = new Article();
            var comment = new Comment(
                "Comment text",
                "John Doe",
                new DateTime(2019, 4, 1));
            sut.AddComment(comment.Text, comment.Author, comment.DateCreated);
            sut.Comments.Should().BeEquivalentTo(comment);
        }
```
- 통신 기반 테스트 : 유지 보수성 점수가 낮다. 외부 의존성(=목)이 사슬로 있을때 매우 어렵다. 

**스타일 비교하기 : 결론**
<img src ="https://velog.velcdn.com/images%2Fmabr2845%2Fpost%2Fa776f400-96c0-404b-9abc-b9f5a2c44136%2Fimage.png"><br/>
항상 다른 스타일보다 출력 기반 테스트를 선호해야하지만 이를 수행하기는 어렵다.

### 6.3 함수형 아키텍처 이해
**함수형 프로그래밍이란?**  
수학적 함수를 사용한 프로그래밍을 말한다.  
즉 수학적 함수는 숨은 입출력이 없는 함수이다.  
수학적 함수는 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성한다.  
입출력을 명시한 수학적 함수는 이를 따르는 테스트가 짧고 간결하며 이해하고 유지보수하기 쉬우므로 테스트하기 매우 쉽다.  
반면 숨은 입출력은 코드를 테스트하기 힘들게 한다.    
메서드가 수학적 함수인지 판별하는 법은 해당 메서드에 대한 호출을 반환 값으로 대체할 수 있는지 확인하는 것이다.  

ex) 수학적 함수 O
```
public int Increment(int x)
{
    return x + 1; 
}
```
ex) 수학적 함수 X  
반환값이 메서드의 출력을 모두 나타내지 않으므로 반환값으로 대체 할 수 없다.  
숨은 출력은 필드 x의 변경이다.
```
int x = 0;
public int Increment()
{
    x++;
    return x; 
}
```

**함수형 아키텍쳐란?**  
어떤 사이드 이펙트도 일으키지 않은 애플리케이션은 만들 수 없다.  

함수형 프로그래밍의 목표는   
부작용을 완전히 제거하는 것이 아닌 비지니스 로직을 처리하는 코드와 부작용을 일으키는 코드를 분리하는 것이다.  

두가지 유형으로 분리
- 결정을 내리는 코드 = 함수형 코어 :   
부작용이 필요 없기 때문에 수학적 함수를 사용해 작성 할 수 있다.
- 해당 결정에 따라 적용하는 코드 = 가변셀 :  
수학적 함수에 의해 이뤄진 모든 결정을 데이터 베이스의 변경이나 메세지 버스로 전송된 메세지와 같이 가시적인 부분으로 변환한다.

함수형 코어와 가변셀은 다음과 같은 방식으로 협력한다.
- 가변 셀은 모든 입력을 수집
- 함수형 코어는 결정을 생성
- 셀은 결정을 부작용으로 변환  

<img src ="https://velog.velcdn.com/images%2Fmabr2845%2Fpost%2F76bf14d0-001f-49c2-9a03-efb9ed8e4036%2Fimage.png"><br/>
이 두 계층으로 잘 분리하려면 가변 셀이 의사 결정을 추가하지 않게끔 결정을 나타내는 클래스에 정보가 충분히 있는지 확인해야 한다.  
목표는 출력 기반 테스트로 함수형 코어를 두루 다루고 가변셀을 훨씬 더 적은 수의 통합 테스트에 맡기는 것이다.  


**함수형 아키텍처와 육각형 아키텍처 비교**  

공통점  
- 관심사의 분리라는 아이디어를 기반이다.  
- 의존성 간의 단방향 흐름이다. 
  - 육각형 아키텍처의 도메인 계층은 애플리케이션 서비스에 의존하지 않는다.
  - 함수형 아키텍처의 불변 코어는 가변 셀에 의존하지 않는다.

차이점
- 사이드이펙트에 대한 처리
  - 육각형 아키텍처의 도메인 계층에서는 사이트 이펙트 문제가 없다.  
  모든 수정사항은 도메인 계층에 있어야 하며 계층의 경계를 넘어서는 안된다.
  - 함수형 아키텍처는 사이트 이펙트를 불변 코어에서 비즈니스 연산 가장자리로 밀어내어 가변셀이 이를 처리 한다.
  
### 6.4 함수형 아키텍처와 출력 기반 테스트로 전환
**감사 시스템 애플리케이션을 함수형 아키텍처로 리팩터링**
- 프로세스 외부 의존성에서 목으로 변경
- 목에서 함수형 아키텍처로 변경

감사 시스템 예제  
요구사항: 가장 최근 파일의 마지막 줄에 방문자의 이름과 방문시간을 추가한다.  
파일당 최대 항목 수에 도달하면 인덱스를 증가시켜 새파일을 작성한다.  

예제 6.8 감사 시스템의 초기 구현 > p205 참고  
(메서드 한개에 모든 구현이 들어 있음.)

**프로세스 외부 의존성에서 목으로 변경**  
일반적으로 파일 시스템을 목으로 처리해 해결한다.  
파일의 연산을 별도의 클래스로 도출하고 
생성자 주입을 통해 이 클래스를 주입한다.
```java
// 생성자를 통한 파일 시스템(IFileSystem)의 명시적 주입
public class AuditManager
{
    private readonly int _maxEntriesPerFile;
    private readonly string _directoryName;
    private readonly IFileSystem _fileSystem;
    public AuditManager(
        int maxEntriesPerFile,
        string directoryName,
        IFileSystem fileSystem)
    {
        _maxEntriesPerFile = maxEntriesPerFile;
        _directoryName = directoryName;
        _fileSystem = fileSystem;
} }
```
파일 시스템의 분리로 공유 의존성이 사라지고 테스트를 서로 독립적으로 실행할 수 있다.    
테스트는 더이상 파일 시스템에 접근하지 않아도 되서 더 빨리 실행되며 유지비도 절감되었다.  

| |초기버전|목 사용|
|----|----|----|
|회귀 방지|좋음|좋음|
|리팩터링 내성|좋음|좋음|
|빠른 피드백|나쁨|좋음|
|유지 보수성|좋음|좋음|

**목에서 함수형 아키텍처로 변경**  
파일 처리에대한 사이드 이펙트를 클래스 외부로 완전히 이동할 수 있다.   
파일에 디렉터리 경로대신 파일(FilContent)을 배열로 받는다.  
디렉터리 경로로 부터 파일을 읽는 것은 외부로 분리한다.(Persister 클래스)
```java
public class AuditManager {
    
    ... 
    
    public FileUpdate AddRecord(
        FileContent[] files,
        string visitorName,
        DateTime timeOfVisit) { ...}
}
```
```
public class Persister {
    public FileContent[] ReadDirectory(string directoryName) {
        return Directory
            .GetFiles(directoryName)
            .Select(x => new FileContent(
    }
}
```
AuditManager 에서는 비즈니스로직만 남게 되고  
사이드 이펙트에 대한 처리는 Persister가 하게 되었다.   
이것이 비즈니스로직과 사이드 이펙트의 분리이다.  

또한 더 이상 복잡한 목 설정필요 없이 단순한 입출력 테스트 코드 작성이 가능해 졌다.

| |초기버전|목 사용|출력 기반|
|----|----|----|----|
|회귀 방지|좋음|좋음|좋음|
|리팩터링 내성|좋음|좋음|좋음|
|빠른 피드백|나쁨|좋음|좋음|
|유지 보수성|좋음|좋음|좋음|

### 6.5 함수형 아키텍처의 단점 이해하기
함수형 아키텍처의 단점 : 성능 저하, 코드베이스 크기 증가  

함수형 아키텍쳐와 전통적인 아키텍쳐 사이의 선택은 성능과 코드 유지 보수성 사이의 절충이다.  

성능이 그다지 눈에 띄지 않는 시스템은 유지보수성을 향상시키는 편이 낫기 때문에 함수형 아키텍처를 택하는 게 낫다.  
함수형 아키첵처는 함수형 코어와 가변 셀을 분리해야하므로 코딩이 더 필요하다.  

프로젝트가 너무 단순하거나 비즈니스 관점에서 그닥 중요하지 않다면 함수형 아키텍처를 사용하는 것이 별 의미가 없다.  
모든 코드 베이스를 함수형 아키텍쳐로 전환할 수는 없다. 전략적으로 적용해라.  