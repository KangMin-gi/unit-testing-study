# 2장 단위 테스트란 무엇인가
단위 테스트에 접근하는 방법
- 고전파 : 모든 사람이 단위 테스트와 테스트 주도 개발에 원론적으로 접근하는 방식
- 런던파 : 런던의 프로그래밍 커뮤니티에서 시작되었다.

### 2.1 단위 테스트의 정의
단위 테스트의 속성
- 작은 코드 조각을 검증하고
- 빠르게 수행하고 
- 격리된 방식으로 처리하는 자동화된 테스트다.

**격리 문제에 대한 런던파의 접근**  
격리된 방식으로 처리하는 방식을 런던파에서는   
대상 시스템을 협력자에게 격리하는 것을 말한다.  
하나의 클래스가 다른 클래스들에 의존하면 이 모든 의존성을 테스트 대역으로 대테해야 한다.  
즉, 동작을 외부 영향과 분리해서 테스트 대상 클래스에만 집중할 수 있게 한다.  

모든 의존성이 테스트 대역으로 대체 되었기 때문에 어느 부분이 고정 났는지 확실히 알 수 있다.

예제  
온라인 상점에 재고가 충분하다면 구매성공이며, 구매 수량만큼 재고의 수량이 줄어든다.  
재고가 충분하지 않다면 재고는 변하지 않는다.  

고전파 예시 코드 - 운영용 store 객체 사용
```java
public void Purchase_fails_when_not_enough_inventory()
{
	//준비
    var store = new Store();
    store.AddInventory(Product.shampoo, 10);
    var customer = new Customer();
    
    //실행
   	bool success = customer.Purchase(store, Product.Shampoo, 15);
    
    //검증 (실패 했기에 수량 변화가 없음)
    Assert.False(success);
    Assert.Equals(10, store.GetInventory(Product.Shampoo));
 }
```

런던파 예시 코드 - store를 목 객체로 생성
```java
public void Purchase_fails_when_not_enough_inventory()
{
	//준비
    var store = new Mock<IStore>();
    storeMock
    	.Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
        .Return(false)
    var customer = new Customer();
    
    //실행
   	bool success = customer.Purchase(storeMock.Object, Product.Shampoo, 5);
    
    //검증 (실패 했기에 수량 변화가 없음)
    Assert.False(success);
    storeMock.Verify(
    	x => x.RemoveInventory(Product.Shampoo, 5),
        Times.Never);
 }
```
이 두 방식 모두 Customer와 Store 둘 다 효과적으로 검증한다.  
하지만 Customer에 영향을 미치는 Store 내부에 버그가 있으면     
고전파 방식에서는 Customer와 Store 둘 중 어디서 버그가 발생했는 확인하기 어렵다.  

**격리 문제에 대한 고전파의 접근**  
고전파에서는 코드를 꼭 격리하는 방식으로 하지 않아도 된다.  
각각의 테스트를 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 한,   
여러 클래스를 한 번에 테스트해도 괜찮다는 뜻이다.  
데이터베이스, 파일 시스템 등 프로세스 외부 의존성이 공유 상태의 대표적 예다.  

- 공유 의존성(Shared dependency)  
공유 의존성은 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성.  
공유 의존성은 테스트 대상 클래스(단위) 간이 아니라 단위 테스트 간에 공유한다.  


- 비공개 의존성(Private dependency)  
공유하지 않는 의존성  


- 프로세스 외부 의존성(out-of-process dependency)  
애플리케이션 실행 프로세스 외부에서 실행되는 의존성이며, 아직 메모리에 없는 데이터에 대한 프록시다.  
예를 들어 데이터베이스는 프로세스 외부이면서 공유 의존성이다.  

공유 의존성을 대체하는 또 다른 이유는 테스트 실행 속도를 높이는 데 있다.  
공유 의존성은 거의 항상 실행 프로세스 외부에 있어 호출 시간이 오래 걸린다.  

### 2.2 단위 테스트의 런던파와 고전파
런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 보는 반면,   
고전파는 단위 테스트끼리 격리하는 것으로 본다.  

표 2.1 런던파와 고전파의 차이     


| |격리 주체|단위의 크기|테스트 대역 사용 대상|
|---|---|---|---|
|런던파|단위|단일 클래스|불변 의존성 외 모든 의존성|
|고전파|단위 테스트|단일 클래스 또는 클래스 세트|공유 의존성|

고전파에서는 공유 의존성을 테스트 대역으로 교체한다.   
런던파는 공유 의존성 뿐만 아니라 변경 가능한 비공개 의존성도 테스트 대역으로 교체 할 수 있다.  

### 2.3 고전파와 런던파의 비교
**런던파의 접근 방식의 장점**  
- 입자성(granularity)이 좋다.   
테스트가 세밀해서 한 번에 한 클래스만 확인한다.  
-서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다.  
모든 협력자는 대역으로 대체되기 때문이다.  
- 테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다.  

**고전파와 런던파 사이의 다른 차이점**  
- 테스트 주도 개발을 통한 시스템 설계 방식  
  - 런던파는 하향식 TDD로 이어지며, 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트 부터 시작한다.  
  목을 사용해 예상 결과를 달성하고자 시스템이 통신해야 하는 협력자를 지정한다.   
  - 고전파는 테스트에서 실제 객체를 다뤄야 하기 때문에 상향식이다.  
  도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 그 위에 더 둔다.  

- 과도한 명세 문제  
고전파보다 고전파가 테스트 구현에 더 자주 결합된다.

### 2.4 두 분파의 통합 테스트
단위 테스트 정의  
- 런던파 : 작은 코드 조각을 검증하고 빠르게 수행하고 격리된 방식으로 처리한다.  
런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다.


- 고전파 :  단일 동작 단위를 검증하고 빠르게 수행하고 다른 테스트와 별도로 처리한다.

**통합 테스트의 일부인 엔드 투 엔드 테스트**  
통합 테스트는 공유 의존성, 프로세스 외부 의존성뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트다.  
엔드 투 엔드 테스트는 통합 테스트의 일부다.  
주로 엔드 투 엔드 테스트도 코드가 프로세스 외부 종속성과 함께 어떻게 작동하는지 검증한다.  
일반적으로 통합 테스트는 데이터베이스와 파일시스템만 포함하고 결제 게이트웨이는 테스트 대역으로 대체한다.  
하지만 엔드 투 엔드 테스트에서는 이를 포함한다.  
엔드 투 엔드 테스트는 유지 보수 측면에서 가장 비용이 많이 들기 때문에   
모든 단위 테스트와 통합 테스트를 통과한 후 빌드 프로세스 후반에 실행하는 것이 좋다.  
