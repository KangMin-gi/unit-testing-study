- 좋은 단위 테스트의 관점 감 차이점 모색
- 이상적인 테스트 정의
- 테스트 피라미드 이해
- 블랙박스 테스트 및 화이트박스 테스트 사용

## 좋은 개발 스위트는…

- 개발 주기에 통합되어 있다.
- 코드베이스의 가장 중요한 부분만을 대상으로 한다.
- 최소한의 유지비, 최대의 가치
    - 가치있는 테스트 식별
    - 가치있는 테스트 작성

가치 있는 테스트를 작성하기 위해서는 가치 있는 테스트를 식별할 수 있어야 한다.

## 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기

1. 회귀 방지
2. 리팩터링 내성
3. 빠른 피드백
4. 유지 보수성

### 4.1.1 첫 번째 요소 : 회귀 방지

- 회귀 : 코드에 수정이 가해진 다음 기능이 의도한 대로 작동하지 않는 경우
- 코드베이스가 커질수록 잠재적인 버그에 더 많이 노출되며 회귀에 대해 효과적인 보호를 개발하는 것이 중요하다.
    - 이런 보호가 없다면 프로젝트 성장은 어려워지고 수 많은 버그가 쌓이게 된다.
- 테스트코드가 회귀방지에 얼마나 좋은 점수를 내는지 평가하려면 다음 사항들이 고려되어야 한다.
    - 테스트 중에 실행되는 코드의 양
    - 코드 복잡도
    - 코드의 도메인 유의성
- 실행되는 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다.
- 물론 이 테스트에 관련된 검증이 있다고 가정한다면 단순히 코드만 실행시키는것만으로는 충분하지 않다.
- 검증을 통해 이 테스트가 예외를 발생시키지 않고 실행되는 것은 알 수 있지만, 테스트 코드가 생성하는 결과의 유효성도 확인해야한다.
- 코드의 복잡도와 도메인 유의성도 중요하다.
    - 복잡한 비즈니스 로직을 나타내는 코드가 보일러플레이트 코드보다 훨씬 더 중요하다.
    - 비즈니스의 중요한 기능에서 발생한 버그가 가장 큰 피해를 입힌다.
- 단순한 코드를 테스트 하는 것은 거의 가치가 없다.
- 직접 작성하지 않은 코드 역시 스스로 작성한 코드 만큼 소프트웨어 작동에 영향을 미친다.
    - 테스트가 해당 라이브러리, 프레임워크등을 테스트 범주에 포함시키도록 해 의존성에 대해 검증이 올바른지 확인한다.
- 회귀 방지 지표를 극대화 하려면 테스트가 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.

### 4.1.2 두 번째 요소 : 리팩터링 내성

- 기존 코드를 리팩터링 해도 테스트 결과에 영향을 미치면 안된다.
- 거짓 양성 :  어떤 기능의 기반 코드를 수정한 이후 예전과 같이 완벽하게 작동하지만 테스트는 실패하는 경우. 이는 실제로 기능의 작동 여부와는 상관없다.
    - TL:DR → 실제로 의도한 대로 작동하지만 테스트는 실패하는 케이스
- 내부 구현을 수정하지만 식별할 수 있는 동작은 유지할 때 발생한다.
- 거짓 양성은 전체 테스트 스위트에 치명적인 영향을 줄 수 있다.
- 기존 기능이 고장 났을 때 테스트가 조기 경고를 제공한다.
    - 테스트가 타당한 이유 없이 실패하면, 코드 문제에 대응하는 능력과 의지가 희석된다.
- 코드 변경이 회귀로 이어지지 않을것이라 확신할 수 있다.
    - 테스트 스위트에 대한 신뢰가 떨어지게 되며, 더 이상 믿을만한 테스트로 인식하지 않게 된다. 회귀를 피하기 위해 코드 리팩토링을 최소한으로 줄이게 된다.

### 4.1.3 무엇이 거짓 양성의 원인인가?

- 테스트에서 발생하는 거짓 양성의 수는 테스트 구성 방식과 직접적인 관련이 있다.
    - 테스트와 테스트 대상 시스템의 구현 세부 사항이 많이 결합할수록 더 많은 허위 경보가 생긴다.
    - 이를 위해 해당 구현 세부 사항에서 테스트를 분리하는 것이다.
    - 테스트를 통해 테스트 대상 시스템이 제공하는 최종 결과(절차가 아닌 식별할 수 있는 동작)를 검증하는지 확인해야 한다.

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b745f815-85a7-4404-8b6f-c24167fc608f/Untitled.png)


### 4.1.4 구현 세부 사항 대신 최종 결과를 목표로 하기

- 코드의 내부 작업과 테스트 사이를 가능한 한 멀리 떨어뜨리고 최종 결과를 목표로 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e596c83b-7a38-49ae-ae67-837d642232b8/Untitled.png)

- 최종 사용자에게 의미 있는 결과를 검증해야한다.

## 4.2 첫 번째 특성과 두 번째 특성 간의 본질적인 관계

- 테스트 정확도 극대화
- 거짓 양성과 거짓 음성의 중요성

### 4.2.1 테스트 정확도 극대화

![회귀 방지는 거짓 음성에서, 리팩터링 내성은 거짓 양성에서 보호한다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de1838d0-440a-4ba6-9856-47db9168f453/Untitled.png)

회귀 방지는 거짓 음성에서, 리팩터링 내성은 거짓 양성에서 보호한다.

- 테스트가 오류를 잡아내지 못하면 문제가 된다.
    - 거짓 음성
- 테스트의 맥락에서 긍정은 어떤 조건이 사실임을 의미한다.
    - 조건이란 테스트가 반응하도록 작성자가 설정한 조건을 뜻한다.
- 거짓 양성과 거짓 음성의 확률이 낮을수록 더 정확한 테스트를 뜻한다.
    - 테스트가 얼마나 버그 있음을 잘 나타내는가 : 거짓 음성 제외
    - 테스트가 얼마나 버그 없음을 잘 나타내는가 : 거짓 양성 제외

![Noise가 적은 강한 Signal을 생성하면 테스트가 정확해진다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0aa26f95-fe83-4b10-8165-e928e9ac6c96/Untitled.png)

Noise가 적은 강한 Signal을 생성하면 테스트가 정확해진다.

- 테스트 정확도를 올리는 방법 두가지
    - Signal 을 증가 시킨다. → 회귀를 더 잘 찾아내는 테스트로 개선시키기
    - Noise를 감소 시킨다. → 허위 경보를 발생시키지 않는 테스트로 개선시키기

### 4.2.2 거짓 양성과 거짓 음성의 중요성 : 역학 관계

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2a54ab97-315a-4a74-9730-be00d1cfb42d/Untitled.png)

## 4.3 세 번째 요소와 네 번째 요소 : 빠른 피드백과 유지 보수성

- 빠른 피드백
    - 테스트 속도가 빠를수록 테스트 스위트에서 더 많은 테스트 수행이 가능하고 더 자주 실행할 수 있다.
    - 테스트가 빠르게 실행되면 코드에 결함이 생기자마자 버그에 대해 경고하기 시작할 정도로 피드백 루프를 대폭 줄여 버그 수정 비용을 거의 0까지 줄일 수 있다.
- 유지 보수성
    - 테스트 코드의 난해함
        - 테스트의 크기가 작을수록, 라인이 적을수록 읽기 쉬우며 필요시 변경이 용이하다.
            - 다만 인위적으로 테스트를 압축하지 말아야한다.
        - 테스트 작성시 절차를 생략하지 말라.
        - 테스트 코드를 일급 시민으로 취급하라.
    - 테스트 실행의 어려움
        - 테스트가 외부 프로세스 외부 종속성으로 작동하면, 데이터베이스 서버를 재부팅하고 네트워크 연결 문제를 해결하는 등 의존성을 상시 운영하는 데 시간을 들여야 한다.

## 4.4 이상적인 테스트를 찾아서

- 좋은 단위 테스트의 4대 특성
    - 회귀 방지
    - 리팩터링 내성
    - 빠른 피드백
    - 유지 보수성
- 4가지 특성의 가치를 모두 곱하면 테스트의 가치를 알 수 있다.
    - 즉 하나라도 0이되면 테스트의 가치는 0이 된다.
- 물론 이런 특성을 정확하게 측정하는 것은 불가능하다.
    - 테스트에 붙여서 수치를 정확히 얻을 수 있는 코드 분석 도구는 없다.
    - 다만 이 네가지 특성과 관련해 테스트가 어디쯤 있는지 비교적 정확하게 평가가 가능하다.
    - 이 평가는 테스트의 가치 추정치를 제시하며, 이 추정치로 테스트 스위트에 테스트를 계속 둘지 여부를 결정한다.
- 테스트 코드를 포함한 모든 코드는 책임(liability 부채에 더 가까운 의미)이다.
    - 최소 필수값에 대해 상당히 높은 임계치를 설정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨야한다.
    - 소수의 가치있는 테스트가 다수의 평범한 테스트보다 프로젝트 성장에 더 효과적이다.

### 4.4.1 이상적인 테스트를 만들 수 있는가?

- 네 가지 특성 모두에서 최대 점수를 받은 테스트를 이상적인 테스트로 본다.
    - 최소값을 0, 최대값을 1로 봤을때 모두 1을 받아야한다.
- 하지만 이건 사실상 불가능하다.
    - 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문
        - 하나를 희생해야 나머지 둘을 최대로 맞출 수 있다.

### 4.4.2 극단적인 사례 1 : 엔드 투 엔드 테스트

![엔드 투 엔드 테스트는 회귀 오류와 거짓 양성에 대한 보호를 훌륭히 해내지만, 빠른 피드백의 지표에서 실패했다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a47442b-35bd-4884-ad52-d5d9cf037e86/Untitled.png)

엔드 투 엔드 테스트는 회귀 오류와 거짓 양성에 대한 보호를 훌륭히 해내지만, 빠른 피드백의 지표에서 실패했다.

- 최종 사용자 관점에서 시스템을 살펴본다.
- 많은 코드를 테스트 하기 때문에 회귀 방지를 훌륭히 해낸다.
- 거짓 양성에 면역이 되어 리팩터링 내성도 좋다.
    - 리팩터링을 올바르게 진행했다는 가정하에 식별할 수 있는 동작을 변경하지 않으므로 엔드 투 엔드 테스트에 영향을 미치지 않는다.
        - On the other hand, end-to-end tests are good at resistance to refactoring because they test the application as a whole, rather than just individual parts.
          This means that if a change is made to one part of the application, end-to-end tests can help ensure that everything still works as expected, even if the change affects other parts of the application.
        - Since end-to-end tests cover the entire application, they can help ensure that changes to one part of the application don't inadvertently break another part.

### 4.4.3 극단적인 사례 2 : 간단한 테스트

-

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/001dca79-83c9-4a59-8d81-a963677b3ba5/Untitled.png)

- 간단한 테스트는 매우 빠르게 실행되고 빠른 피드백을 제공한다.
- 거짓 양성 발생 가능성이 매우 낮다.
- 다만 기반 코드에 실수할 여지가 많지 않아 간단한 테스트는 회귀를 나타내지 않을 것이다.
    - 간단한 테스트는 이름만 바꿀 뿐 ‘동어 반복 테스트(tautology test)를 불러온다.
        - 이런 테스트는 사실상 검증하는 것이 없기 때문에 무의미하다.

### 4.4.4 극단적인 사례 3 : 깨지기 쉬운 테스트

- 리팩터링을 견디지 못하고 기능의 고장 여부와 상관없이 테스트가 항상 실패한다.

### 4.4.5 이상적인 테스트를 찾아서 : 결론

- 유지 보수성은 엔드 투 엔드 테스트를 제외하고는 처음 세 가지 특성과 상관관계가 없다.
    - 엔드 투 엔드 테스트는 관련된 모든 의존성을 설정해야 하므로 크기가 크고 이런 의존성을 계속 운영하려면 추가적인 노력이 필요하다. 즉 유지비 측면에서 더 비싸다.
- 좋은 테스트를 만드는 특성간 균형을 이루는것은 어렵다.
- 서로 조금씩 양보해서 만들어야 할까?
    - 리팩터링 내성은 포기할 수 없다.
        - 엔드 투 엔드 테스트만 진행하거나 테스트가 상당히 빠르지 않은 한, 리팩터링 내성을 최대한 많이 갖도록 해야한다.
    - 결국 얼마나 버그를 잘 찾아내는지(회귀 방지)와 얼마나 빠른지(빠른 피드백) 사이의 선택으로 절충이 귀결된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/36248051-ccec-42c0-8311-9da81f51bc34/Untitled.png)

- 리팩터링 특성은 테스트에 있거나 없거나. 둘 중 하나다.

## 4.5 대중적인 테스트 자동화 개념 살펴보기

- 앞에 나온 좋은 단위 테스트의 네 가지 특성은 기초에 해당한다.

### 4.5.1 테스트 피라미드 분해

- 테스트 피라미드란 테스트 스위트에서 테스트 유형 간의 일정한 비율을 일컫는 개념이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/511dff46-58d4-494b-b457-e4294fbc879f/Untitled.png)

- 테스트 피라미드는 종종 세 가지 유형의 테스트가 있는 피라미드로 표현한다.
    - 각 층의 너비는 테스트 스위트에서 해당 테스트가 얼마나 보편적인지를 나타낸다. 즉, 넓을수록 해당 테스트는 많아진다.
    - 각 층의 높이는 이런 테스트가 최종 사용자의 동작을 얼마나 유사하게 흉내 내는지 나타내는 척도이다.
    - 피라미드 상단의 테스트는 회귀방지에 유리한 반면, 하단은 실행 속도를 강조한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e3d5b747-a376-4db3-bd2f-a406c9cfe6f8/Untitled.png)

- 어떤 계층도 리팩터링 내성을 포기하지 않는다.
    - 엔드 투 엔드 테스트와 통합 테스트가 단위 테스트보다 리팩터링 내성 지표가 더 높지만, 제품 코드에서 분리했을 때의 사이드 이펙트만큼일 뿐이다.
    - 모든 테스트는 거짓 양성을 가능한 한 적게 하는 것을 목표해야한다.
- 테스트 유형 간 정확한 비율은 팀과 프로젝트마다 상이할 수 있다.
    - 일반적으로 피라미드 형태를 유지한다.
    - 엔드 투 엔드가 가장 적고 단위 테스트가 가장 많다.
    - 엔드 투 엔드가 가장 적은 이유는 빠른 피드백이 어렵고 유지 보수성이 결여 되어 있는데 이는 크기가 큰 편이라 관련 프로세스 외부 의존성을 유지하는 데 노력을 더 들여야 한다.
        - 따라서 엔드 투 엔드 테스트는 가장 중요한 기능에 적용할때와 단위 테스트나 통합 테스트와 동일한 수준으로 보호할 때만 적용된다.
- 테스트 피라미드에는 예외가 있다.
    - 모든 애플리케이션 비즈니스 규칙이나 기타 복잡도가 거의 없는 기본적인 CRUD 작업이라면,  테스트 피라미드는 단위 테스트와 통합 테스트의 수가 같고 엔드 투 엔드 테스트가 없는 직사각형처럼 보일 것이다.
    - 단위 테스트는 알고리즘이나 비즈니스 복잡도가 없는 환경에서는 유용하지 않으므로 간단한 테스트 수준까지 빠르게 내려간다.
    - 반명 통합 테스트는 그 가치가 잘 지켜진다.
        - 코드가 아무리 단순하더라도 데이터베이스와 같이 다른 하위 시스템과 통합돼 잘 작동하는지 확인한다.
        - 아주 단순한 예에서는 통합 테스트가 단위 테스트보다 훨씬 더 많을 수 있다.
    - 프로젝트 외부 의존성 하나만 연결하는 API인 경우도 예외에 속한다.

### 4.5.2 블랙박스 테스트와 화이트박스 테스트 간의 선택

- 블랙박스 테스트
    - 시스템의 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법
    - 애플리케이션이 무엇을 해야 하는지 중심으로 구축
- 화이트박스 테스트
    - 애플리케이션의 내부 작업을 검증하는 테스트 방식
    - 테스트는 요구 사항이나 명세가 아닌 소스 코드에서 파생

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ce016cb-8724-4db9-8b75-e822b47858be/Untitled.png)

- 화이트박스 테스트가 더 철저한 편이다.
    - 소스 코드 분석하면 외부 명세에서 놓칠 수 있는 부분을 잡을 수 있다.
- 다만 화이트박스 테스트는 테스트 대상 코드의 특정 구현과 결합되어 있기 때문에 깨지기 쉽다.
    - 많은 거짓양성, 리팩터링 내성 지표 부족
    - 비즈니스 담당자에게는 그다지 의미가 없을 수 있다.
- 리팩터링 내성은 양보할 수 없는 지표이므로 화이트박스 보다는 블랙박스 테스트를 기본으로 선택하자.
- 모든 테스트가 시스템을 블랙박스로 보게 만들고 문제 영역에 의미 있는 동작을 확인하라.
- 테스트를 통해 비즈니스 요구 사항으로 거슬러 올라갈 수 없다면 이 테스트는 깨지기 쉬우니 해당 테스트는 재구성하거나 삭제하는것이 좋다.
- 테스트 작성시에는 블랙박스를, 분석할때는 화이트 박스 방법을 사용할 수 있다.
    - 코드 커버리지 툴을 사용해 어떤 코드 분기를 실행하지 않았는지 확인하고 다음 코드 내부 구조에 대해 전혀 모르는 것처럼 테스트 하라.