#1장 단위 테스트의 목표

단위 테스트는 단순히 테스트를 작성하는 것 보다 더 큰 범주다.  
단위 테스트에 시간을 투자 할 때는 항상 최대한 이득을 얻도록 노력해야하며,  
테스트에 드는 노력을 가능한 줄이고 그에 따르는 이득을 최대화해야 한다.  

이 책으로  
어떤 단위 테스트 기술이 좋은지를 구별할 수 있게 되고  
테스트에 대한 비용 편익 분석(cost-benefit analysis) 방법을 배우고  
특정 상황에서 적절한 테스트를 적용할 지를 배우고  
공통적인 안티 패턴(처음에는 괜찮은 것 같지만 미래에 문제를 야기하는 패턴)을 피하는 방법도 배운다.  

### 1.1 단위 테스트 현황
대부분의 프로그래머 단위테스트를 실천하고 중요성을 알고 있다.  
단위 테스트를 적용할지 말지는 더 이상 논쟁이 아니며  
논쟁은 좋은 단위 테스트를 작성하는 것은 어떤 의미인가 이다.  

###1.2 단위 테스트의 목표
코드베이스에 대한 단위 테스트 작성이 필요하면 일반적으로 더 나은 설계로 이어진다.  
하지만 이는 단위 테스트의 주 목표가 아니며 단지 좋은 사이드 이펙트이다.  
단위 테스트의 목표는  
프로젝트의 지속 가능한 성장을 가능하게 하는 것이다.   

테스트가 없는 프로젝트의 성장추이  
테스트가 없는 프로젝트가 시작에는 유리하지만  
나중에는 개발 속도가 현저히 느려지고 하나의 버그를 수정하면 더 많은 버그를 양산하고  
소프트웨어의 한부분을 수정하면 다른 부분들도 고장이 나게 될 것이다.  
테스트로 이러한 경향을 뒤집을 수 있다.  

테스트는 초반에 노력이 필요하지만    
테스트 후반에도 잘 성장할 수 있음을 확인 할 수 있다. (지속성 + 확장성)    

### 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

프로그래머가 특정 커버리지 지표를 목표로 하는 것은 해로우며  
테스트 스위트 품질을 결정하는 커버리지 지표에 의존할 수 없다.  
가장 많이 사용되는 커버리지 지표로는 코드 커버리지와 분기 커버리지가 있다.

**코드 커버리지 지표에 대한 이해**  
코드 커버리지(테스트 레버리지) = 실행 코드 라인 수/ 전체 라인

```java
public static boolean isLongString(String input) {
  if (input.length > 5)
    return true;
  return false;
}

public void test() {
  boolean result = isLongString("abc");
  Assertions.isEqual(false, result);
}
```

코드 커버리지는 메서드 전체라인 수는 5줄이고 테스트가 실행되는 라인수는 4줄 이므로 4/5 = 80% 이다.

불필요한 if문을 한줄로 처리하면?

```java
public static boolean isLongString(String input) {
  return input.Length > 5;
}

public void test() {
  boolean result = isLongString("abc");
  Assertions.isEqual(false, result);
}
```

메서드 전체라인수 3줄 테스트가 실행되는 라인수는 4줄로 테스트 커버리지는 100 % 가 되었다.  
이 예제는 커버리지 숫자에 대해 얼마나 쉽게 장난칠 수 있는지 보여준다.  
코드가 작을수록 테스트 커버리지 지표는 더 좋아지지만 이는 라인 수 만 줄었을 뿐  
유지 보수성이 좋아진다고 볼 수 없다.  

**분기 커버리지 지표에 대한 이해**  
분기 커버리지는 코드 라인수를 사용하는 대신 if 문과 switch 문과 같은 제어 구조에 중점을 둔다.  
분기 커버리지 = 통과 분기/전체 분기 수

```java
public static boolean isLongString(String input) {
  return input.length > 5;
}

public void test() {
  boolean result = isLongString("abc");
  Assertions.isEqual(false, result);
}
```

isLongString 메소드에서 발생하는 분기는 5글자를 넘는 경우, 넘지 않는 경우 총 2이다.  
여기서는 1개의 분기에 대해서만 테스트 하므로 1/2 = 50 % 이다.

**커버리지 지표에 관한 문제점**

- 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다.  
  커버리지 지표가 의미있으려면 모든 측정 지표를 검증해야 한다.
- 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.

```java
public static int parse(String input) {
  return Integer.parseInt(input);
}

public void test() {
  int result = parse("5");
  Assertions.isEqual(5, result);
}
```

분기커 버리지 지표는 100 %이다.

하지만 입력 매개변수를 변경하면 다른 결과로 나올 수 있고 테스트로 부터 숨어있는 분기가 많다.

- null빈 문자열
- 3.14(정수가 아님)
- 12345..... (너무 긴 문자열)

이와 같이 수많은 edge case 가 있지만 테스트에서는 모든 케이스를 다루는지 확인할 방법이 없다.

**특정 커버리지 숫자를 목표로 하기**  
시스템의 핵심 부분은 커버리지를 높게 두는 것이 좋다.  
하지만 이 높은 수준을 요구 사항으로 삼는 것은 좋지 않다.

### 1.4 무엇이 성공적인 테스트 스위트를 만드는가?
성공적인 테스트 스위트의 특성

- 개발 주기에 통합돼 있다.
    - 이상적으로는 코드가 변경 될 때마다 아무리 작은 것이라도 실행해야 한다.
- 코드베이스에서 가장 중요한 부분만을 대상으로 한다.
    - 애플리케이션의 가장 중요한 부분은 비즈니스로직(도메인 모델)이다.
      비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다.
- 최소한의 유지비로 최대의 가치를 끌어낸다.
    - 가치 있는 테스트(더 나아가 가치가 낮은 테스트) 식별하기
    - 가치 있는 테스트 작성하기.
      이를 위해서는 코드 설계 기술도 알아야 한다.

### 1.5 이 책을 통해 배우는 것
테스트 스위트 내에 모든 테스트를 분석하는 데 사용할 수 있는 기준틀(=기초)을 설명한다.  
그리고 새로운 관점에서 많은 테스트를 볼 수 있으며,  
어떤 것이 프로젝트에 기여하고 어떤 것을 리팩터링해야 하거나 완전히 제거해야 하는 지 알 수 있을 것이다.