## 단위테스트 스타일

항상 나오는 것들
- 4대요소 (회귀 방지, 리퍁겉링 내성, 빠른 피드백, 유지 보수성)
---
### 단위 테스트의 스타일
 - 출력 기반
   - SUT에 입력을 넣고, 출력을 점검한다.
   - 내부에서 상태를 변경하거나, 외부에 저장하지 않는 순수함수의 기반 코드에서 작동
     - ex. ```int  add(int a, int b)``` 요론 느낌의 간단한 함수
   - 함수형 프로그램 원칙을 사용해, 기반코드가 함수형 아키텍쳐를 지향하게끔 재구성
   - 
 - 상태 기반
   - SUT에 입력을 넣고, 시스템 상태를 확인한다. 
   - 상태라는건 SUT의 협력자, 또는 외부의존성의 상태
     - Class Member Field, DB 같은 느낌도 포함되는듯.
 - 통신 기반
   - 목을 사용 하는 스타일

--- 
### 스타일 별 단위 테스트의 4대요소
 - **회귀 방지**
   - 각 스타일별로 회귀 방지 지표가 달라지지는 않는다.
   - 회귀 방지의 지표는 ```코드의 양, 코드 복잡도, 도메인 유의성```
   - 세가지 스타일(출력, 상태, 통신) 모두 크게 관계가 없다.
     - 스타일에 대한 문제이지, 코드의 양은 구현하기 나름. 딱히 종속적이진 않다.
     - 코드 복잡도와 도메인 유의성도 마찬가지
       - 코드 복잡도는 구현코드에 관한거지, 테스트의 스타일에 관한건 아니다.
       - 통신기반 스타일에서 코드 조각을 검증하는 피상적인 테스트가 될 경우는 영향 있음 (?)
 - **피드백 속도**
   - 테스트 스타일과 피드백 속도 사이는 상관이 크지 않음
     - 세가지가 동일하게 외부 의존성과 관련없는 단위 테스트에 있을 경우에만.
     - 물론 목을 이용할경우 약간의 지연시간인데 미미
 - **리팩터링 내성**
   - 코드의 구현 세부 사항에 결합된 테스트의 결과
   - 출력 기반 테스트 
     - 현 세부사항과 결합하지 않아서 가장 우수 (메서드 시그니쳐만 보고 있어서 그런듯)
     - 출력 기반 테스트가 구현 세부사항과 결합하려면, 메서드 자체가 구현 세부사항일 때 (private method ?)
   - 상태 기반 테스트
     - 리팩터링 내성이 높진 않다.
     - 상태 기반 테스트는 큰 API 노출 영역에 의존, 구현 세부 사항과 결합할 가능성도 더 높다
       - 멤버 필드나 DB 값은, 다른 노출 영역과 닿아 있기 때문일까? 여러 곳에서 쓰는거라(?) 
   - 통신 기반 테스트
     - 매우 취약, Mock을 이용한 건 구현과 굉장한 연관이 있어서 리팩터링 내성이 떨어짐
     - 스텁과 상호작용을 하는건 넣으면 안된다.
 - **유지 보수성 지표**
   - 유지보수성은 단위 테스트와 밀접한 관련
     - 유지 보수성은 테스트를 이해/실행 하는 난이도 두가지를 측정
   - 출력 기반 테스트는 입력 + 출력 단 두개만 비교해서 짧고, 외부 의존성이 없어 실행하기 쉽다.
   - 상태 기반 테스트는 상태 검증에 대해 많은 이해가 필요 (출력기반 테스트에 비해)
     - 물론 equals나 여러 테스트용 헬퍼 메소드를 통해 간결하게 가능,
     - 테스트용 헬퍼 메소드는 테스트를 위한 메소드라 코드 오염 문제로 권장하지 않는다
 - **결론**
   - 세가지 모두 피드백 속도와 회귀 방지는 동일
   - **항상 출력 기반 테스트를 선호해라**
   - 사실상 불가
     - 출력 기반 스타일은 함수형으로 작성된 코드에만 작용하기 때문 (객체지향은 해당하지 않지)
     - 코드를 순수 함수로 만들면 가능하긴 하다.

---
### 함수형 아키텍쳐
 - 순수 함수(수학적 함수) 를 사용한 프로그래밍
   - 순수 함수 : 모든 입출력을 메소드 시그니처에 명시하고, 멱등성을 보장, 숨은 입출력이 없음 (상태를 변경한다던지)
 - 숨은 입출력은 테스트를 힘들게 한다 
   - 숨은 입출력의 종류는 side effect(부작용), exception(예외), reference to an internal or external state (내외부 상태에 대한 참조)
   - side effect 
     - 안에서 외부의 상태를 스리슬쩍 바꾼다던지 외부에 파일을 쓴다던지 모르는 행동들
   - exception
     - 시그니처에 표현하지 않는 우회된 경로가 생김
     - 시그니처가 전달하지 안흔 출력을 추가 (우회 해서 어디로 갈지 몰라서)
   - 내외부 상태 참조
     - LocalDateTime.now() 같은것
     - 데이터베이스 자료
 - 참조 투명성 -> 메소드가 순수 함수인지 판단 하는 가장 좋은 방법
   - 동작을 변경하지 않고, 해당 메서드에 대한 호출을 반환값으로 대체 가능한가?
```java
public class Test {
    
    // 이 함수는 코드 사이에 increase(4) 를 5 로 대체 가능하다
    // 이게 참조 투명성  
    public int increase(int a) {
        return a + 1;
    }
    
    // 참조 투명성 없음 SideEffect 많음
    int x;
    public int increase2() {
        return ++x;
    }
}
```

 - 위 함수만을 가지고 애플리케이션을 만들 순 없다.
 - **함수형 프로그래밍의 목적은, 부작용(숨은출력?) 을 완전히 제거하는 것이 아님**
 - **비즈니스 로직을 처리하는 코드와 숨은 입출력(부작용?)을 일으키는 코드를 분리하는 것!**
 - 함수형 아키텍쳐는 순수 함수로 작성된 코드를 극대화

---
### 결정을 내리는 코드 (함수 코어, 불변코어) + 결정에 따라 외부 행동 (가변 셀)
 - ```가변셀은 모든 입력을 수집``` -> ```함수 코어가 결정 생성``` -> ```셀이 외부 행동(부작용 생성)```
   - 책에 셀은 결정을 부작용으로 변환한다. (The Shell converts the domain into side effect)
   - 부작용이 있는 코드로 변환해서 실행한다 같은 느낌이겠지?
 - 가변 셀이 의사 결정을 추가하지 않게 코어 클래스에 정보가 있는지도 확인

참고 : 캡슐화와 불변성 (작동 부분을 최소화 한다는건 뭘까)
```
두개에는 깊은 연관성이 있는데, 캡슐화는 코드에 모순이 안생기도록
불변성은 불변 클래스를 사용해 처음부터 변형 불가
그러므로 불변 클래스를 사용하는 함수형 프로그래밍은 캡슐화가 필요 없다.

**
객체지향 프로그래밍은 작동 부분을 캡슐화해 코드를 이해할 수 있게 한다.
함수형 프로그래밍은 작동 부분을 최소화해 코드를 이해할 수 있게 한다.
**
```

### 함수형 아키텍쳐와 육각형 아키텍쳐
 - 육각형 아키텍쳐는 도메인 계층과 애플리케이션 서비스 계층을 구별
 - 도메인 계층 클래스는 서로에게만 의존 <> 함수형 아키텍처의 불변 코어는 가변 셀에 의존하지 않음
   - 바깥으로 나가는 방향은 없다는 의미
 - 함수형 아키텍처는 부작용을 연산 가장자리로 (가변 셀로) 밀어낸다.
 - 육각형 아키텍처는 모든 수정 사항은 도메인 계층에 있어야함, 계층의 경계를 넘어설 순 없다.
 - 도메인 클래스는 DB에 저장은 불가하지만, 상태는 변경 가능
   - 애플리케이션에서 이 변경을 DB에 저장 (이게 가변셀 역할인가?)
 - 함수형 아키텍처는 육각형 아키텍처의 하위 집함 (일부란 의미?)
   - 극단적으로 함수형 아키텍처 == 육각형 아키텍처

---

### 함수형 아키텍처의 출력 기반 테스트로 전환
 - 죄송합니다
   








---

### 그외
 - **코드오염**
   - 단위 테스트를 가능/간결 하게 하기위해 코드에 추가한것들