## 통합 테스트

### 단위 테스트에만 전적으로 의존하면 시스템이 전체적으로 잘 작동하는지 확실 불가 해서 통합 테스트가 필요하다

---

### 톱합 테스트란
 - 단위 테스트의 조건 중 하나라도 충족 못한 것
    - 단일 동작 검증
    - 빠르게 수행
    - 다른 테스트와 별도로 수행
 - 실제 통합 테스트 대부분은 시스템이 프로세스 외부 의존성과 톱합 했을 때 어떻게 작동하는지를 검증
 - 단위 테스트는 도메인 모델을 다룸 / 통합 테스트는 프로세스 외부 의존성과 도메인 모델을 연결하는 코드를 확인
 - 컨트롤러 부분 테스트에 관해
    - 협력자수가 많고, 복잡도가 낮은 컨트롤러
    - **이 부분을 통합 테스트로 다룬다**  
    - 모든 외부 프로세스를 목으로 대체하면, 단위 테스트가 될 수 있다.
    - 데이터베이스는 목으로 대체할 수 없다 (?)
 - 단위 테스트와 통합 테스트의 비율
    - 단위 테스트로 가능한 많은 비즈니스 시나리오 예측
    - 통합 테스트로 주요 흐름(ok case)과 단위테스트에서 사용할 수 없는 기타 예외
    - 단순한 어플리케이션이면, 통합테스트와 단위 테스트 숫자는 같을수 밖에 없음
      - 도메인 모델 / 알고리즘 코드가 거의 없기 떄문
      - 심지어 단위 테스트는 없을수도 있음
 - 통합 테스트로 주요 흐름과, 단위 테스트로 못잡는 예외 다루는 방법
   - 통합 테스트에서 프로세스 외부 의존성과의 상호 작용을 모두 확인하려면, 가장 긴 주요 흐름을 선택하라
      - 모든 외부 시스템과의 통신을 거치는 부분을 확인하라는 의미?
      - 이런 흐름이 없으면, 모든 외부 시스템과의 통신을 확인하는데 필요한 만큼의 통합 테스트를 작성
 - 하단 코드에서의 의문
```
UserController 의 if 부분
이 부분을 테스트하는게 단위 테스트로 발견 못하는 부분을 테스트 할 수 있다.
하지만 가치가 충분한가? 는 생각을 해볼법한 내용
User 에도 동일한 테스트를 하고 있고, 단위 테스트로도 충분한 테스트 이기 떄문이다
```
```java
// 최종 코드 ORM 사용

@RequiredArgsConstructor
public class UserController {
    
    // DI 로 주입
    private final UserRepo userRepo;
    private final MessageBus mb;
    
    @Transactional
    public void chaneEmail(Long userId, String newEmail) {
        User user = this.userRepo.findById(userId);
        if (user.canChangeEmail()) {
            // 예외 처리 후 종료
        }
        user.changeEmail(newEmail);
        mb.sendEvent(new UserEmailChageEvent(user));
    }
}

@Entity
public class User {
    private Long userId;
    private String email;
    private UserType type;
    
    @ManyToOne
    private Comapny company;
    
    public boolean canChangeEmail() {
        // 판단 하는 부분
    }
    
    public void changeEmail(String email) {
        
        if (this.canChangeEmail()) {
            throw new IllegalArgumentException();
        }
        
        if (this.email.equals(email)) {
            return;
        }
        
        UserType newType = this.company.isEmailCorp(newEmail)
                ? UserType.EMP
                : UserType.OUTER;
        
        if (this.type != newType) {
             int changeNumber = newType == UserType.EMP ? 1 : -1;
             this.company.addEmpCount(changeNumber);
        }
        
        this.email = email;
        this.type = newType;
    }
    
}

@Entity
public class Company {
    
    private String emailDomain;
    private Integer empCount;
    
    public boolean isEmailCorp(String email) {
        return emailDomain.equals(email.split("@")[1]);
    }
    
    public void addEmpCount(int changeNumber) {
        this.empCount += changeNumber;
        this.validEmpCount();
    }
    
    private void validEmpCount() {
        if (empCount <= 0) {
            throw new IllegalArgException();
        }
    }
}
```

```
빠른 실패 원칙
 - 버그를 빠르게 나타내는것
 - 빠른 실패는 예기치 않은 오류가 발생하자 마자 현재 연산을 중단하는것,
 - 파일을 읽어서 로드하는 부분을, 어플리케이션 앞단에 내는 것도 빠른실패와 관련이 있다
 - 전제 조건도 여기 포함된다.
 - 그런데 갑자기 여기서 어느 부분이 빠른 실패인걸까 (?)
```

---

### 어떤 프로세스 외부 의존성을 직접 테스트
 - 통합 테스트는 시스템이 프로세스 외부 의존성과 어떻게 통합하는지를 검증
 - 실제 프로세스 외부 의존성 사용 / 목 사용 의 두가지 방식
 - 어떤 방식을 선택하는가?
 - 프로세스 외부 의존성에는 두가지 유형이 있다.
   - 관리 의존성 : 애플리케이션을 통해서만 접근 가능하며, 외부에서는 볼 수 없는 부분 (DB)
   - 비관리 의존성 : 상호작용을 외부에서도 볼 수 있는 부분 (MQ, Kafka, SMTP 등)
 - 관리 의존성과의 통신은 테스트하지 않고, 비관리 의존성과의 통신만 테스트
   - **관리 의존성**과의 통신은 세부 구현!
      - 하위 호환성을 유지할 필요가 없다 (외부에 열려있지 않기 떄문)
      - 통합 테스트에서 실제 인스턴스를 사용하기 좋은 부분 (칼럼 변경, DB 이관등 최종 상태를 확인 할 수 있어 좋은 부분)
   - **비관리 의존성**과의 통신은 시스템의 식별할 수 있는 동작
      - 하위 호환성을 키기 위해 통신 패턴을 유지해야 한다. (?)
      - 여기에는 목이 제일 좋다
 - 관리의존성 인데 비관리 의존성인것
   - 다른 APP 과 공유하는 DB와 같은 경우
   - 다른 애플리케이션이 볼 수 있는 부분은 비관리 의존성 처럼 처리 (Mocking?)
   - 다른 애플리케이션이 못 보는 부분은 관리 의존성 처럼 처리
   - 꼭 필요한 부분이 아니라면, 시스템이 해당 테이블과 상호 작용하는 방식을 변경하지 말라
      - 테스트를 위한 리팩토링으로 함부로 바꾸지 말라는 말인가?
 - 실제 인스턴스를 사용 못하는 경우
   - DB 로 설명한다.
   - CI 하는 부분에 별도의 DB를 못둘수 도 있고, 보안 정책에 해당될 수도 있다.
   - 이 상황에서 통합테스트를 위해, 관리 의존성인 부분을 모킹하는건 그저 호출에 대한 검증밖에 안된다.
   - 도메인 단위 테스트에 집중하고 통합 테스트를 아예 작성하지 않는 것이 좋다.
```
좋지 않은 테스트를 작성하는 것보다는 테스트를 작성하지 않는 것이 좋다.
```

---
### 통합 테스트의 예제
하단의 코드로 진행

```java
import java.beans.Transient;

@RequiredArgsConstructor
public class UserController {

   // DI 로 주입
   private final UserRepo userRepo;
   private final MessageBus mb;

   @Transactional
   public void chaneEmail(Long userId, String newEmail) {
      User user = this.userRepo.findById(userId);
      if (user.canChangeEmail()) {
         // 예외 처리 후 종료
      }
      user.changeEmail(newEmail, company);
      mb.sendEventList(user.events());
   }
}

@Entity
public class User {
   private Long userId;
   private String email;
   private UserType type;
   private boolean confirmed;

   @Transient
   private List<CustomEvent> events = new ArrayList<>();

   @ManyToOne
   private Comapny company;

   public boolean canChangeEmail() {
      // 판단 하는 부분
      return !this.confirmed;
   }

   public void changeEmail(String email) {

      if (this.canChangeEmail()) {
         throw new IllegalArgumentException();
      }

      if (this.email.equals(email)) {
         return;
      }

      UserType newType = this.company.isEmailCorp(newEmail)
              ? UserType.EMP
              : UserType.OUTER;

      if (this.type != newType) {
         int changeNumber = newType == UserType.EMP ? 1 : -1;
         this.company.addEmpCount(changeNumber);
      }

      this.email = email;
      this.type = newType;
      
      this.events.add(new UserEmailChangeEvent(this));
   }

}

@Entity
public class Company {

   private String emailDomain;
   private Integer empCount;

   public boolean isEmailCorp(String email) {
      return emailDomain.equals(email.split("@")[1]);
   }

   public void addEmpCount(int changeNumber) {
      this.empCount += changeNumber;
      this.validEmpCount();
   }

   private void validEmpCount() {
      if (empCount <= 0) {
         throw new IllegalArgException();
      }
   }
}
```

 - 어떤 시나리오를 테스트 해야하는가
   - 통합 테스트는 전체 긴 시나리오를 테스트 한다. (이메일을 변경)
      - 여기에는 부작용이 DB Update + MessageBus 에 메세지를 보냄
      - 그러므로 이 메소드를 테스트 (의존성을 전부 사용해서)
   - 이메일 변경할 수 없는 시나리오는 테스트 할 필요가 없다.
      - 컨트롤러에 이러한 확인이 없으면 애플리케이션이 빨리 실패하기 떄문 (?)
      - 단위 테스트에서 하고 있어서 그런건가? 그러면 구현 세부사항을 보면서 테스트 하는게 되는것은 아닌가
      - 통합 테스트의 목적은 외부 의존성과 연결이 목적이라 괜찮은걸까
   - 데이터 베이스는 실제 인스턴스로 사용해야 하고 메세지 버스는 비관리 의존성이라 목으로 대체해야 한다.
 - End to End 는 어떤가
   - End to End 는 목으로 전혀 대체하지 않는 부분 
   - 통합 테스트의 보호 수준이 End to End와 비슷해져서 생략 할 수도 있다.
   - 프로젝트 전체적인 점검을 위해 모킹 안한 테스트가 있는것도 괜찮다
   

---

### 의존성 추상화를 위한 인터페이스 사용
 - Service, ServiceImpl 과 같은 구조가 있다.
   - OOP의 공개 폐쇄 원칙 + 추상화해 느슨한 결합을 위해 만들어짐
 - 위 부분은 오해가 있다.
   - 단일 구현을 위한 인터페이스는 추상화가 아님
      - 적어도 두개의 구현체가 있어야 진정한 추상화
      - 공부할때 본적있다. 다형성을 사용하지 않은 상속은 has-a로 처리해라
   - YAGNi를 위반하기 떄문
      - YAGNI : 현재 필요하지 않은 기능에 시간을 들이지 말라
 - 프로세스 외부 의존성에 인터페이스를 쓰는 것
   - 목을 사용하기 위해 쓴다. (?)
   - 인터페이스가 없으면 테스트 대역을 만들 수 없다
   - 결론적으로 비관리 의존성에 대한 테스트 대역을 작성하기 위해 인터페이스를 쓰라는 말
 - 프로세스 내부 의존성에 인터페이스를 쓰는것
   - 위의 User 클래스를 Interface로 할 수도 있다.
   - 프로레스 외부 의존성과 마찬가지로 목으로 처리하기 위해서는 할수 있음
   - 그러나 외부 의존성과 달리 도메인 클래스 간의 상호 작용을 확인해선 안된다. (?)
      - 결국 하지 말라는거 같은데..
   
---

### 통합 테스트의 모범 사례
```
 - 도메인 모델 경계 명시하기
 - 애플리케이션 내 계층 줄이기
 - 순환 의존성 제거하기
```

도메인 모델 경계 명시하기
 - 항상 도메인 모델을 코드베이스에서 명시적이고 잘 알려진 위치에 둬라
 - 단위 테스트는 도메인 모델과 알고리즘을 대상, 통합 테스트는 컨트롤러를 대상
 - 경계는 별도의 어셈블리 / 네임 스페이스 형태를 취할 수 있다.
    - 패키지 같은 경계인듯
   
계층 수 줄이기
 - 애플리케이션의 추상 계층이 너무 많으면 코드베이스를 탐색하기 어렵고, 숨은 로직 찾기가 어렵다
 - 간접 계층은 코드를 추론하는데 부정적인 영향
 - 계층이 많은 코드는 컨트롤러와 도메인 모델 사이에 명확한 경계가 없다.
   - 이는 계층을 따로 검증할 떄 그저 목을 호출해서 의미없는 검증 테스트를 하게 된다
 - 가능한 한 간접 계층을 적게 사용해라
 - 대부분 백엔드는 도메인 모델 + 애플리케이션 서비스 계층 (컨트롤러) + 인프라 계층 세개만 사용하면 된다

순환 의존성 제거하기
 - 대표적으로 콜백
   - 종종 코딩하다 보면 this를 넘기게 되는 부분이 생기는데, 그런걸 얘기하는 듯
 - 알아야 할 것이 너무 많아지고, 주변 그래프를 전체 한번 확인해야 한다.
 - 순환 의존성은 테스트도 방해
 - 순환 의존성을 만드는 대신에, 작업 결과를 리턴해서 쓰면 리팩토링이 가능하다.