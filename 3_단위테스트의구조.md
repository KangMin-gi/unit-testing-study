## 단위 테스트의 구조

---
### 단위 테스트를 구성하는 방법
1. AAA
   - Arrange (준비), Act(실행), Assert(검증)
   - 본적있다. Given When Then
   - 각 영역을 순서대로 작성한다.
     - 개발 순서가 아니라 코드 순서이다.
     - tdd를 할 때면 준비는 모르고, 실행과 검증만 알 게 되는데 이에 억메일 필요 없다.
     - 그렇지만 먼저 코드르 완성하고 테스트를 짤 경우에는, 개발도 코드순서와 똑같이
   - 각 주석 또는 줄로 구분하여 작성한다.
     - 준비단계가 크면 주석을 쓰는게 좋다 (준비단계 에서도 개행으로 가독성 상승)
     - 준비단계가 작다면, 주석을 없애고 라인으로 구분하라
     - 실행단계는 끽해야 몇줄, 검증단계도 몇줄 안되기 떄문에
   
### 테스트에서 조심해야 할 부분 
- 여러개의 구절 피하기
  - 항상 그렇다.
  - 여러개의 준비, 실행, 검증 구절은 테스트가 너무 많은것을 한번에 검증
  - 여러줄은 여러개의 테스트로 나눠 작성하는것
  - 통합 테스트의 경우 속도와 타협하기 위해 종종 그런경우도 있다.
- if문 피하기
  - if문은 결국 또다른 테스트가 있다는 반증
  - 항상 테스트를 나눠라

### 각 구절 크기에 대한 고찰
- 일반적으로, 준비문의 구절이 가장 클 수밖에 없다.
  - 준비 구절을 줄이기 위한 방법
    - 멤버에 선언 vs 팩토리 패턴
    - 팩토리 패턴이 좋다. 멤버에 선언할 경우 값을 변경하면 다른 테스트의 동작에 문제가 가기 때문에 수정하기 힘들다.
      - 테스트의 독립적 실행에 문제가 가는건 아니고, 독립적 수정에 문제가 감
    - 코드에 대한 가독성도 굉장히 떨어진다.
- 실행 구절은 보통 한줄이다. (여러개가 있으면 나눠라)
  - 두줄이 된다면, 두개의 테스트가 동시에 진행되거나, 해당 기능의 캡슐화가 완전히 깨진것
  - 고전파처럼 여러 동작을 하나로 테스트하면, 해당 기능은 잘못 개발된 가능성이 높다.
  - 비즈니스 로직에는 대부분 적용되지만, 유틸리티나 인프라 코드는 다를 수 있다.
  - 예시코드

```java

/*
- 아래 코드에서 구매와 minus가 따로 있는것은 기능적 캡슐화에 완전히 어긋난 상태이다.
 - purchase가 Minus 호출을 강제해야 한다는것은 있을 수 없음
  */

public class T {
    
    @Test
    public void purchaseTest() {
        
        Store store = new Store();
        Customer cus = new Customer();
        
        cus.purchase(Shampoo, 5);
        store.minusProduct(Shampoo, 5);
        // 이부분 궁금하다. minusProduct도 단위테스트에 들어가야 할 부분 아닌가?
        // 물론 purchase와 결합해서 들어가는건 맞는걸로 생각하지만, 별도로 저것도 하나의 기능으로 봐야하나?
        // 실제 구동하는 기능이 있으면 하는거고 없으면 안하는걸까?
        
        assert...
    }
}
```

- 검증문
    - 검증문은 하나여야 한다는 것은, 런던파의 이야기?
    - 단위테스트가 동작에 대해 움직인다면 여러 결과에 대한 검증이 필요함
    - 주로 기대하는 객체를 만들어서 검증하는게 좋다.

### 종료문에 대해
 - 종료 구절이 있기도 한데, AAA패턴은 이단계를 포함하지 않는다.
 - 단위 테스트는 외부 종속적이지 않으므로 이 단계가 필요가 없다.

### Sut
 - 테스트 대상에 대한 이야기인데, 기능이 돌아가는 코드는 여러가지일 수 있지만, 진입점은 하나여야 한다.
 - 그게 곧 하나의 동작을 얘기하는 거고, 단위테스트당 동작은 한줄만 있어야하기 때문


### 테스트의 명명 규칙
 - 테스트 명명 규칙은 자유롭게 가는게 제일 좋다.
 - 테스트 이름에 SUT의 메서드 이름을 포함하지 말라
 - 테스트 명명 규칙이 있다는걸 처음 알았다.
 - 항상 문장으로 또는 한글로 적기 떄문에 있는줄 몰랐는데 이 방법이 좋은 방법 
 - sum_of_two_numbers() -> 두_수의_합_성공()? 이런식으로
 - Delivery_with_past_date_is_invalid -> 배송_날짜가_잘못된_경우_에러()

### 라이브러리의 사용
 - Junit의 ParameterTest() 나 CsvSource() 와 같은 기능으로 동일한 기능, 파라미터가 다른 경우는 테스트 하는게 좋아 보인다.
   - 항상 있는 임계값 테스트와, 양수 음수 변환 등 항상 동일한 성공(케이스) 는 해당 기능을 사용
   - 너무 많이 사용하려다, 테스트의 순수함이 깨질 수 있을듯 하더라
   - 종종 결과를 넘어오는 값에따라 분기하는 코드도 본 적 있다
 - 라이브러리로 가독성 증가
   - assertJ나 Hamcrest(난 써본적 없다) 와 같은 것들은 가독성이 올라간다.
   - assertThat(result).isTrue()
   - assterThatThrownBy(() -> customer.purchase(null)).isIstanceOf(NullPointException.class)


### 궁금쓰
 - 고전파의 방법은, API의 통합 테스트 또는 API 단위테스트랑 좀 다른가?
 - 클래스명 아래에, 기능 단위의 검증 method가 올라가 있는게 맞는걸까?
   - 시작점이 그기라 괜찮을지도