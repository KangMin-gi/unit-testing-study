# 3장. 단위 테스트 구조


<aside>
💡 3장에서 다루는 내용
<br>ㅁ 단위 테스트 구조
<br>ㅁ 좋은 단위 테스트 명명법
<br>ㅁ 매개변수화된 테스트 작성
<br>ㅁ Fluent Assertions 사용

</aside>

# 3장에서는..

- 준비(Arrange), 실행(Act), 검증(Assert) 를 사용한 단위 테스트 구조를 살펴본다.
- 단위 테스트 프레임워크(xUnit)을 소개한다.
- 왜 xUnit 을 선택했는지 설명한다.
- 단위 테스트 명명법을 소개한다.
- 왜 좋은 선택이 아닌지 살펴본다.
- 단위 테스트 프로세스를 간소화하는 데 도움되는 프레임워크 기능을 이야기한다.

<br>

# 3.1 단위 테스트를 구성하는 방법

- 준비, 실행, 검증 패턴을 사용해 단위 테스트를 구성하는 방법
- 피해야 할 함정을 알아본다.
- 가능한 한 읽기 쉽게 만드는 방법을 알아본다.

## 3.1.1 AAA 패턴 사용

- AAA 패턴은 각 테스트를 준비, 실행, 검증이라는 세 부분으로 나눌 수 있다.
- 준비 구절
    - 테스트 대상 시스템과 해당 의존성을 원하는 상태로 만든다.
- 실행 구절
    - SUT 에서 메서드를 호출하고 준비된 의존성을 전달하며 출력값을 캡처(= 변수에 저장)한다.
- 검증 구절
    - 결과를 검증한다.
    - 반환 값이나 SUT로 표시될 수 있다.
    - 협력자의 최종 상태로 표시될 수 있다.
    - SUT가 협력자에 호출한 메서드로도 표시될 수 있다.
- `Given-When-Then 패턴`
    - AAA 와 유사한 패턴이다.
    - **Given** : 준비 구절에 해당
    - **When** : 실행 구절에 해당
    - **Then** : 검증 구절에 해당
    - 구성 측면에서 두 가지 패턴 사이에 차이는 없다.
    - 유일한 차이점은 Given-When-Then 구조가 비프로그래머에게 더 읽히기 쉽다는 것.
- 테스트 작성 시 **준비 구절부터 시작**하는 것이 자연스럽다.
- 그 후 나머지 두 구절을 작성한다.
- 검증 구절부터 시작하는 것도 가능한 옵션이다.
- 직관적이지 않을 수 있지만, 특정 동작이 **무엇을 해야 하는지에 대한 목표를 생각하면서 시작**한다.

## 3.1.2 여러 개의 준비, 실행, 검증 구절 피하기

- 준비, 실행 또는 검증 구절이 여러 개 있는 테스트를 만날 수 있다.
    - 이러한 테스트는 더이상 단위 테스트가 아닌  `통합 테스트`다.
- 실행이 하나면 테스트가 단위 테스트 범주에 있게끔 보장하고, 간단하고, 빠르며, 이해하기 쉽다.
    - **각 동작을 고유의 테스트로 도출하라.**
- 통합 테스트에서는 실행 구절을 여러 개 두는 것이 괜찮을 때도 있다.
    - 통합 테스트는 느릴 수 있다.
    - 속도를 높이는 방법은 여러 개의 통합 테스트를 여러 실행과 검증이 있는 단일한 테스트로 묶는 것!
- 시스템 상태의 흐름이 자연스럽다면, 실행이 동시에 후속 실행을 위한 준비로 제공될 때 특히 유용하다.
- 그러나 단위 테스트나 충분히 빠른 통합 테스트에서는 이러한 최적화가 필요하지 않다.
    
    `→ 항상 다단계 단위 테스트를 여러 개의 테스트로 나누는 것이 좋다.`
    

## 3.1.3 테스트 내 if 문 피하기

- if 문이 있는 단위 테스트는 `안티 패턴`이다.
- if 문이 많다면 한 번에 너무 많은 것을 검증한다는 뜻이다.
- 이런 테스트는 반드시 여러 테스트로 나눈다.
    - 단위 or 통합 테스트 예외가 없다.
- 분기는 추가 유지 비용만 늘어날 뿐이다.

## 3.1.4 각 구절은 얼마나 커야 하는가?

### 준비 구절이 가장 큰 경우

- 일반적으로 준비 구절이 가장 크다.
- 실행과 검증을 합친 만큼 보다 클 수도 있지만 이런 경우 같은 테스트 클래스 내 비공개 메서드 또는 별도의 팩토리 클래스로 도출하는 것이 좋다.
- 준비 구절에서 코드 재사용에 도움이 되는 두 가지 패턴으로 `오브젝트 마더`와 `데이터 빌더`가 있다.

### 실행 구절이 한 줄 이상인 경우를 경계하라

- 실행 구절은 보통 코드 한 줄이다.
- 두 줄 이상인 경우 SUT 의 공개 API에 문제가 있을 수 있다.

```cpp
// 실행
bool success = customer.Purchase(store, Product.Shampoo, 5);
store.RemoveInventory(success, Product.Shampoo, 5);
```

- 첫 번째 줄에서 고객에 상점에서 샴푸 다섯 개를 구매하려고 한다.
- 두 번째 줄에서 재고가 감소된다. 그러나 Purchase() 호출이 성공한 경우만 수행된다.
- 이는 단일 작업을 수행하는 데 두 개의 메서드 호출이 필요하다는 것이다.
    - (테스트 자체는 문제가 없다..)
    - 테스트는 구매 프로세스라는 동일한 동작 단위를 검증한다.
    - 클라이언트에게 메서드 호출을 더 강요해서는 안된다.
    - 비즈니스 관점에서 구매가 정상적으로 이뤄지며 고객의 제품 획득과 매장 재고 감소라는 두 가지 결과가 만들어진다.
    - 두 번째 메서드가 호출되지 않을 때 문제가 발생한다.
    - 이런 모순을 불변 위반(invariant violation)이라고 한다.
        - 잠재적 모순으로부터 코드를 보호하는 행위를 캡슐화(encapsulation)라고 한다.
    - 절대 두 줄 이상이 안된다고 할 수는 없다.
        - 비즈니스 로직을 포함하는 대부분 코드에는 적용되지만, 유틸리티나 인프라 코드는 덜 적용된다.
    

## 3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가?

- 테스트당 하나의 검증을 갖는 지침이 있다.
- 즉 가능한 한 가장 작은 코드를 목표로 하는 전제에 기반을 둔다.
    - 이 전제는 옳지 않다.
- 단위 테스트의 단위는 `동작의 단위`이지 코드의 단위가 아니다.
- 단일 동작 단위는 여러 결과를 낼 수 있다.
- 하나의 테스트로 그 모든 결과를 평가하는 것이 좋다.
- 그럼에도 불구하고 검증 구절이 너무 커지는 것은 경계해야 한다.
- 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버를 정의하여 검증하는 것이 좋다.

## 3.1.6 종료 단계는 어떤가

- 네 번째 구절로 종료 구절을 따로 구분하기도 한다.
- 대부분의 단위 테스트는 종료 구절이 필요하지 않다.
- 단위 테스트는 프로세스 외부에 종속적이지 않으므로 처리해야 할 사이드 이펙트를 남기지 않는다.

## 3.1.7 테스트 대상 시스템 구별하기

- SUT 는 애플리케이션에서 호출하고자 하는 동작에 대한 진입점을 제공한다.
- 이 동작은 여러 클래스에 걸쳐 있을 수도 있고, 단일 메서드로 작을 수도 있다.
    - 그러나 진입점은 오직 하나이다.
- SUT 를 의존성과 구분하는 것이 중요하다.

## 3.1.8 준비, 실행, 검증 주석 제거하기

- 테스트 내에서 특정 부분이 어떤 구절에 속하는지 쉽게 구분하도록 **주석을 추가**하거나 **빈줄로 분리**한다.
- 대규모 테스트에서는 쉽지 않다.
    - 대규모 테스트에서는 준비 단계에 빈 줄을 추가해 설정 단계를 구분할 수도 있다.
- 결론
    - AAA 패턴을 따르고 준비 및 검증 구절에 빈 줄을 추가하지 않아도 되는 테스트라면 구절 주석을 제거해라.
    - 그렇지 않으면 구절 주석을 유지하라.

<br>

# 3.2 xUnit 테스트 프레임워크 살펴보기

- 모든 객체지향 언어(자바, C++, 자바스크립트 등)에 단위 테스트 프레임워크가 있고 매우 비슷하다.
- xUnit 을 선호하는 이유는 NUnit 보다 깨끗하고 간결하기 때문이다.
- 추가 구성(TestFixture 또는 SetUp)이 필요했던 많은 개념이 이제 컨벤션과 내장 언어 구조에 의존하게 됐다.
- ‘각 테스트는 이야기가 있어야 한다.’ → 문제 영역에 대한 개별적이고 원자적인 사실이나 시나리오이다.
- 테스트가 통과한다는 것은 사실 또는 시나리오가 실제 사실이라는 증거다.
- 제품 코드의 기능을 무조건 나열하기 보다는 애플리케이션 동작에 대해 고수준의 명세가 있어야 한다.(개발자뿐 아니라 비즈니스 담당자에게도 의미가 있어야 함.)

<br>

# 3.3 테스트 간 테스트 픽스처 재사용

- 테스트에서 언제 어떻게 코드를 재사용하는지 아는 것이 중요하다.
- 테스트 픽스처(TestFixture)
    1. 테스트 픽스처는 테스트 실행 대상 객체다. 정규 의존성(SUT 로 전달되는 인수)이다.
    2. 다른 정의는 NUnit 테스트 프레임워크에서 테스트가 포함된 클래스를 표시하는 특성이다.
    
    → 이 책에서는 1번 정의 사용
    
- 테스트 픽스처 재사용 방법 : 테스트 생성자에서 픽스처를 초기화하는 것
    - 테스트 코드의 양을 크게 줄일 수 있다.
    - 테스트 픽스처 구성을 전부 또는 대부분 제거할 수 있다.
    - 단점
        - 테스트 간 결합도가 높아진다.
        - 테스트 가독성이 떨어진다.

## 3.3.1 테스트 간의 높은 결합도는 안티 패턴이다

- 테스트를 수정해도 다른 테스트에 영향을 주어서는 안된다.
- 테스트의 준비 로직을 수정하면 클래스의 모든 테스트에 영향을 미친다? → 안티 패턴

## 3.3.2 테스트 가독성을 떨어뜨리는 생성자 사용

- 준비 코드를 생성자로 추출하면 테스트 가독성이 떨어진다.
- 테스트가 무엇을 테스트하는지 보려면 클래스의 다른 부분도 봐야 한다.
- 준비 로직이 별로 없어도 테스트 메서드로 바로 옮기는 것이 좋다.
    - 그럼 단순히 인스턴스를 만드는 것인가?
    - 다른 곳에서 환경 설정을 하는 것인가?
        
        → 독립적인 테스트는 이런 불확실성이 없다.
        

## 3.3.3 더 나은 테스트 픽스처 재사용법

- 생성자 대신 비공개 팩토리 메서드를 두는 것이다.
- 공통 초기화 코드를 비공개 팩토리 메서드로 추출해 테스트 코드는 짧게 만들어 테스트의 전체적인 맥락을 만든다.
- 태스트 픽스처 재사용 규칙에 한 가지 예외가 있다.
    - 테스트 전체 또는 대다수에서 사용되는 생성자에 픽스처를 인스턴스화 한다. ( 데이터베이스와 작동하는 테스트가 이에 해당함.)
    - 모든 테스트가 데이터베이스 연결이 필요하여 한번 연결 초기화한 후 어디서나 재사용한다.
    - 이런 경우는 기초 클래스를 두어 클래스 생성자에서 데이터베이스 연결을 초기화하는 것이 더 합리적이다.


<br> 

# 3.4 단위 테스트 명명법

- 표현력 있는 이름도 중요하다.
- 유명하지만 가장 도움이 되지 않는 명명법

```cpp
[테스트 대상 메서드]_[시나리오]_[예상 결과]
```

- 테스트 대상 메서드 : 테스트 중인 메서드 이름
- 시나리오 : 메서드를 테스트하는 조건
- 예상 결과 : 현재 시나리오에서 테스트 대상 메서드에 기대하는 것
- 동작 대신 세부사항에 집중하게 해 좋지 않다.
- 간단하고 쉬운 영어 구문이 훨씬 효과적이다.

```cpp
public void Sum_of_two_numbers()
public void Sum_TwoNumbers_ReturnsSum()
```

→ 전자가 더 가독성이 좋다.

## 3.4.1 단위 테스트 명명 지침

- 엄격한 명명 정책을 따르지 않는다. 표현의 자유를 허용하자.
- 문제 도메인에는 익숙하지만 비개발자인 사람들에게 시나리오를 설명하는 것처럼 짓자.
- 단어를 밑줄 표시로 구분하자. 긴 이름 가독성 향상에 효과적이다.
    - 테스트 클래스 명명시에는 밑줄 표시를 하지 않는다.
    - 테스트 클래스 명명은 `[클래스명]Tests` 패턴을 사용하지만 해당 클래스만 검증하는 것으로 제한하지 않는다. → 단위 테스트에서 `단위는 동작 단위`지, 클래스 단위가 아니라는 것을 기억하자.
    

## 3.4.2 예제 : 지침에 따른 테스트 이름 변경

```cpp
public void IsDeliveryValid_InvalidDate_ReturnsFalse() {
	...
}

public void Delivery_with_invalid_date_should_be_considered_invalid() {
	...
}
```

- 두 번째 이름이 비개발자인 사람들에게 납득시키기 쉽다.
- SUT 의 메서드 이름은 더 이상 테스트명에 포함되지 않는다.
- 추가 예시들

```cpp

```

<br>

# 3.5 매개변수화된 테스트 리팩터링하기

- 테스트 하나로 동작 단위를 완전히 설명하기에는 충분하지 않다.
- 각 구성 요소는 자체 테스트로 캡처해야 한다.
- 동작이 복잡하면 테스트 수가 급격히 증가할 수 있고 관리하기 어려울 수 있다.
- 매개변수화된 테스트는 `유사한 기능을 묶을 수 있는 기능`을 제공한다.

**[몇 가지 사실을 포괄하는 테스트]**

```cpp
public class DeliveryServiceTests {
	[InlineData(-1, false)]
	[InlineData(0, false)]
	[InlineData(1, false)]
	[InlineData(2, true)]
	[Theory]
	public void Can_detect_an_invalid_delivery_date(int daysFromNow, bool expected) {
		DeliveryService sut = new DeliveryService();
		DateTime deliveryDate = DateTime.Now.AddDays(daysFromNow);
		Delivery delivery = new Delivery {
			Date = deliveryDate
		};

		bool isValid = sut.IsDeliveryValid(delivery);

		Assert.Equal(expected, isValid);
	
	}
}
```

- 별도의 테스트가 아니라 [InlineData] 라인으로 표현한다.
- 매개변수화된 테스트는 코드 양을 줄일 수는 있겠지만 비용이 발생한다.

**[긍정적 시나리오와 부정적 시나리오를 검증하는 두 가지 테스트]**

```cpp
public class DeliveryServiceTests {
	[InlineData(-1)]
	[InlineData(0)]
	[InlineData(1)]
	[Theory]
	public void Detect_an_invalid_delivery_date(int daysFromNow) {
		...
	}

	public void The_soonest_delivery_date_is_two_days_from_now() {
		...
	}

}
```

- 코드 양과 코드의 가독성을 서로 상충된다.
- 매개변수 만으로 테스트 케이스를 판단할 수 있다면 긍정 테스트와 부정 테스트 케이스를 모두 하나의 메서드로 두는 것이 좋다.
- 동작이 너무 복잡하면 매개변수화된 테스트를 사용하지 마라.
    - 각각 고유의 테스트 메서드로 나타내라.

## 3.5.1 매개변수화된 테스트를 위한 데이터 생성

- xUnit 에는 테스트 메서드에 공급할 사용자 정의 데이터를 생성하는 기능이 있다.

<br>

# 3.6 검증문 라이브러리를 사용한 테스트 가독성 향상

- Fluent Assertions 라이브러리
    - 숫자, 문자열, 컬레션, 날짜 및 시간 등에 대해 검증할 수 있는 헬퍼 메서드를 제공한다.
    - 유일한 단점이 프로젝트에 의존성을 추가해야 한다는 것.