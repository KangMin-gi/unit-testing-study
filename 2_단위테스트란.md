## 단위 테스트란 무엇인가.

### 단위 테스트
 - 코드의 단위를 검증
 - 빠르게 수행
 - 격리된 방식으로 처리

---
### 해석의 차이에 따른 두가지 타입
 - 목 추종자 (런던파)
 - 디트로이트 (고전적) 
 - 이 차이는, ```격리된 방식으로 처리하는``` 이란 대목에서, 격리의 의견 차이에서 나오게 된다.

런던파
 - 런던파는 하나의 클래스가, 다른 클래스에 의존하게되면 그부분을 전부다 테스트 대역으로 생각
 - 테스트 단위: 클래스
 - 불변 객체를 제외한 모든 의존성 (런던파도 허가하는 Enum?)
 - 코드와 결합도가 높아짐 (내부에서 모킹할 api를 다 보면서 해야함)
 - 장점
   - 코드 베이스의 고장난 부분을 바로 알 수 있다.
   - 복잡한 객체 그래프 (심지어 순환이 참조된) 에서 테스트 하기 용이
   - 객체 그래프를 다시 만들 필요없이, 그래프를 효과적으로 분해해 단위 테스트 준비가 용이
   - 테스트를 만들기 용이하다. 그저 메소드마다 만들면 끝! (장점인지 모르겠다)
   - 테스트가 실패 시 디버깅이 쉽다. (하나의 클래스만 테스트 하기 떄문)
   - 
 - 예시코드 (Mock이 생각 안나서 수도코드급으로 작성)
   - 오직 Customer 클래스만 테스트할 뿐, Store는 전부다 관련된 모킹으로 처리한다. 
```java

public class Test { 
    
    Mock<Store> storeMock = Mock.createMock(Store.class);
    
    @Test
    public void 상품_구매() {
        
        storeMock.call(storeMock.hasEnoguht(Product.Shampoo, 5))
                .then(true); // hasEnought를 호출하면 항상 true
        Customer customer = new Customer();
        
        boolean success = customer.purchase(storeMock.object(), 5);
        
        assertThat(success)
                .isTrue();
    }
    
}
```

고전파
 - 코드를 꼭 격리할 필요는 없다. 대신 단위세트는 서로 격리해서 실행해야 한다
 - 테스트 대역을 사용할 순 있지만 테스트 간 공유 상태를 일으키는 의존성에 대해서만 사용한다.
 - 단위테스트가 반드시 클래스에 국한될 필요는 없다. 공유 의존성이 없는 한 여러 클래슬르 묶어서 단위 테스트를 할 수 있다.
 - 테스트 단위는 기능(동작)에 초첨 맞춰져 있다.
   - 심지어는 비개발자, 기획자가 봐도 될 이야기
 - 장점
   - 테스트 실행 속도가 빨라진다.
   - 복잡한 클래스 그래프가 나오지 않도록 억제하는 순기능이 있다.
     - 반대로 말하면 테스트 준비가 어렵지만, 코드의 유지보수성이 올라감
   - 하나의 버그가 전체 시스템에 걸쳐 테스트 실패를 야기
     - 왜 장점인가 하면, 테스트를 주기적으로 하면 해당 코드의 영향도가 어디까지 미치는지 파악이 쉽다.
     - 대신 테스트를 주기적으로 (코드가 머지될때 마다 정도) 돌리지 않으면, 너무 많은 수정사항과 함께 여러 복합적 에러가 나올 수 있어서 조심
     - 
```java

public class Test {
    
    @Test
    public void 상품_구매() {
        
        Store store = new Store(Product.Shampoo, 10); // 많이 차이나는 부분, 실제 객체냐 모킹이냐
        Customer customer = new Customer();
        
        boolean success = customer.purchase(store, 5);
        
        assertThat(success)
                .isTrue();
    }
    
}
```

---
통합테스트
 - 런던파와 고전파의 통합테스트는 느낌이 많이 다르다.
 - 고전파의 의존성이 있는 부분을 같이 테스트하는건, 런던파에겐 통합테스트의 일종
 - 고전파는 단위테스트의 3가지중 하나라도 적용을 못할 경우 통합테스트로 본다.
   - 격리 : 공유 의존성에 접근
   - 빠르게 수행 : 프로세스 외부와 통신하여 시간이 오래 걸리는 테스트
   - 둘 이상의 동작 단위 : 종종 실행 속도를 위해 일어나지만, 이것보다는 다른팀이 개발한 모듈이 있을 경우 

엔드투 엔드
 - 통합 테스트의 일부
 - 외부 종속성과 함께 어떻게 작동하는지 검증한다.
 - 통합테스트와 다르게, 외부 의존성을 전부 또는 대다수 가지고 작동하는 느낌
 - ui 테스트, 기능테스트 등이 동의어
 - SpringBootTest 붙은 느낌인듯하다.

엔드투 엔드와 통합 테스트 예시를 통한 비교
   - DB, FileSystem, 결제 Gateway(다른 팀 모듈) 을 호출한다고 치자
   - DB 와 FileSystem은 테스트에서 들고올 수 있지만, 결제Gateway는 얘기가 다르다.
   - 결제 Gateway를 위한 계정도 발급받고, 해당 계정의 상태를 고정하는 문제도 있다
   - 통합 테스트는 DB + FileSystem
   - 엔드투엔드는 Db + FileSystem + 결제Gateway
   - 꼭 이렇지만은 않다. 진짜로 결제Gateway의 계정을 못들고 올떄도 있어서 테스트 대역으로 둬야 할 수도 있다.
   - 뚜렷한 경계가 있는것은 아님
---
의존성의 종류
 - 공유 의존성 : 테스트간에 공유되고 결과에 영향을 미침
   - public static field, DB, FileSystem 등
 - 비공개 의존성 : 공유하지 않는 의존성
   - 다른 클래스나. 그런것들?
 - 프로세스 외부 의존성 : 애플리케이션 외부 의존성
   - 외부 API 등?
   - 읽기전용 API 같은 건, 외부지만 비공유 의존성

의존성에 대해
 - 공유 의존성에 대해서는, 테스트 대역으로 하거나 테스트간 공유가 되어야 한다.
   - 외부에 있기 떄문에 속도가 빠를 수 없다. 2원칙
   - 