# 7장 가치 있는 단위 테스트를 위한 리팩터링

### 7.1 리팩터링할 코드 식별하기
기반 코드를 리팩터링하지 않고서는 테스트 스위트를 크게 개선할 수 없다.  
테스트 코드와 제품 코드는 본질적으로 관련돼 있기 때문에 다른 방도는 없다.  

제품 코드는 2차원으로 분류
- 복잡도 또는 도메인 유의성:  
코드 복잡도는 코드 내 의사 결정(분기) 지점 수로 정의 한다.  
도메인 유의성은 코드가 프로젝트의 문제 도메인에 대해 얼마나 의미있는지를 나타낸다.  
일반적으로 도메인 계층의 모든 코드는 최종 사용자의 목표와 직접적인 연관성이 있으므로 도메인 유의성이 높다.   
반면 유틸리티 코드는 연관성이 낮다.  
복잡한 코드는 도메인 유의성이 나타나지 않아도 테스트 할 만하며 도메인 유의성이 높은 메서드는 비즈니스에 중요한 기능이미로 테스트를 해야 한다.
- 협력자수  
협력자는 가변 의존성이거나 프로세스 외부 의존성이다.  
협력자가 많은 코드는 테스트 비용이 많이든다.  
도메인 모델이라면 프로세스 외부 협력자를 사용하면 안 된다.
프로세스 외부 의존성을 가진 모든 통신은 도메인 계층 외부의 클래스에 위임하는 것이 좋다.  

코드 복잡도 및 도메인 유의성, 협력자수로 뷴류된 4가지 코드 유형
<img src="https://www.kimcoder.io/assets/images/unit-testing-24.jpg"></br>
1) 도메인 모델과 알고리즘  
보통 복잡한 코드는 도메인 모델이지만, 문제 도메인과 직접적으로 관련이 없는 복잡한 알고리즘이 있을 수 있다.  
단위테스트가 매우 가치 있다.  
2) 간단한 코드  
협력자가 거의 없고 복잡도나 도메인 유의성도 거의 없다.  
단위테스트 할 필요가 없다.  
3) 컨트롤러  
도메인 클래스와 외부 애플리케이션 같은 다른 구성 요소의 작업을 조정한다.  
포괄적인 통합테스트의 일부로서 간단히 테스트 해야 한다.   
4) 지나치게 복잡한 코드  
협력자가 많으며 복잡하거나 중요하다.   
단위 테스트가 매우 어려우며 테스트를 안하고 넘어가기엔 위험하다.

지나치게 복잡한 코드는 피해야하고 도메인 모델과 알고리즘만 단위 테스트하는 것이 매우 가치있고 유지보수가 쉬운 테스트 스위트로 가는 길이다.
지나치게 복잡한 코드를 알고리즘과 컨트롤러로 나눠서 리팩토링해야한다.

**험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기**
지나치게 복잡한 코드를 쪼개려면, 험블 객체 패턴을 써야한다.
<img src="https://www.kimcoder.io/assets/images/unit-testing-21.jpg"><img src="https://www.kimcoder.io/assets/images/unit-testing-22.jpg">
험블 객체 패턴은 지나치게 복잡한 코드에서 로직을 추츨해 코드를 테스트할 필요가 없도록 간단하게 만든다.
추출된 로직은 테스트하기 어려운 의존성에서 분리되어 다른 클래스로 이동한다.  
즉 비즈니스로직과 프로세스 외부의존성과의 통신은 분리 되어야 한다.
이는 단일 책임 원칙을 지키는 것이기도 하다.

### 7.2 가치 있는 단위 테스트를 위한 리팩터링하기
고객 관리 시스템 예제
요구사항
- 사용자 이메일이 회사 도메인에 속한 경우 해당 사용자는 직원으로 표시된다. 그렇지 않으면 고객이다.
- 시스템은 회사의 직원수를 추적해야한다. 사용자 유형이 직원에서 고객으로, 또는 그반대로 변경되면 이 숫자도 변경해야 한다. 
- 이메일이 변경되면 시스템은 메시지 버스로 메시지를 보내 외부 시스템에 알려야한다. 
```java
public void ChangeEmail(int userId, String newEmail){
    // DB에서 사용자의 현재 이메일과 유형 검색
    
    // DB에서 조직의 도메인과 직원수 검색
    
    // 새 이메일의 도메인의 이름에 따라 사용자 유형 설정
    
    // 필요한 경우 조직의 직원수 업데이트
    
    // DB에 사용자 저장
    
    // 메시지 버스에 알름 전송
}
```
현재 User 클래스는 지나치게 복잡한 코드이다.  
명시적 의존성 : userId, newEmail  
암시적 의존성(프로세스 외부 협력자) : DB, MessageBus  

리팩토링   
**1단계 : 암시적 의존성을 명시적으로 만들기**    
테스트 용이성을 개선하는 일반적인 방법은 암시적 의존성을 명시적으로 만드는 것이다.  
즉, 데이터베이스와 메시지 버스에 대한 인터페이스를 두고,   
이 인터페이스를 User에 주입한 후 테스트에서 목으로 처리한다.   
도메인 모델은 외부 시스템과의 통신을 책임지지 않아야 한다.  

**2단계: 애플리케이션 서비스 계층 도입**  
User클래스로부터 데이터베이스와 메시지버스를 분리하였다.  
User클래스는 더이상 협력자를 처리할 필요가 없기 때문에 도메인 모델에 더 가까워 졌다.  
하지만 UserControlle는 복잡한 로직이 있어 지나틴 복잡한 코드에 경계에 걸쳐 있다.  

**3단계: 애플리케이션 서비스 복잡도 낮추기**   
모든 ORM 라이브러리는 데이터베이스 체이블을 도메인 클래스에 어떻게 매핑하는 지 지정할 수 있게한다.  
ORM을 사용하지 않거나 사용할 수 없으면,    
도메인 모델에 원시 데이터베이스 데이터로 도메인 클래스를 인스턴스화하는 팩토리 클래스를 작성하라.  
이 팩토리 클래스는 별도 클래스가 될 수도 있고, 더 간단한 경우 기존 도메인 클래스의 정적 메서드가 될 수도 있다.  
예제에서 별도의 UserFactory 클래스를 두었다.  
<img src="https://www.kimcoder.io/assets/images/unit-testing-24.jpg"></br>

**4단계 : 새 Company 클래스 소개**  
User에서 업데이트된 직원수를 반환하는 부분이 어색하다.  
회사와 관련된 로직과 데이터를 묶어 Company클래스를 만들어야 한다.  
User 인스턴스는 직원 수를 변경하거나 특정 이메일이 회사 이메일인지 여부 판단은 Company 클래스에게 맡긴다.  

<img src="https://www.kimcoder.io/assets/images/unit-testing-25.jpg"></br>
Company 협력자가 추가되어 User는 오른쪽으로 이동했다.    
모든 복잡도가 팩토리로 이동했기 때문에 UserController는 확실히 컨트롤러 사분면에 속한다.   
이 클래스가 담당하는 것은 모든 협력자를 한데 모으는 것이다.

### 7.3  최적의 단위 테스트 커버리지 분석
| |	협력자가 거의 없음 | 협력자가 많음 |
|----|----|----|
|복잡도와 도메인 유의성이 높음|User의 ChangeEmail(new Email, company), Company의 ChageNumberOfEmployess(delta) -> 비용 편익 측면에서 최상의 결과를 가져다줌.|
|복잡도와 도메인 유의성이 낮음|User와 Company의 생성자| User의 ChangeEmail(new Email, company), Company의 ChageNumberOfEmployess(delta)|

### 7.4 컨트롤러에서 조건부 로직 처리
조건부 로직을 처리하면서 동시에 프로세스 외부 협력자 없이 도메인 계층을 유지 보수하는 것은 까다롭고 절충이 있기 마련이다.  
그 절충이 무엇이며 프로젝트에서 어떤 것을 선택할지 결정하는 방법을 소개한다.  
비즈니스 로직과 오케스트레이션의 분리는 다음과 같은 비즈니스 연산이 세단계로 있을 때 가장 효과적이다  
- 저장소에서 데이터 검색
- 비즈니스 로직 실행
- 데이터를 다시 저장소에 저장   

<img src ="https://www.kimcoder.io/assets/images/unit-testing-26.jpg"><br/>
이와 같이 프로세스 외부 의존성에 대한 모든 참조가 비즈니스 연산의 가장자리로 밀려났을 때 가장 효과적이다.  
그러나 이렇게 단계가 명확하지 않은 경우가 많다.  
이러한 상황을 대처하는 데 3가지 방법이 있다.  
1. 외부에 대한 모든 읽기와 쓰기를 비즈니스 연산 가장자리로 밀어내기 : 컨트롤러를 계속 단순하게 하고 프로세스 외부 의존성과 도메인 모델을 분리하지만 성능이 저하된다.  
2. 도메인 모델에 프로세스 외부 의존성 주입하기 : 성능을 유지하면서 컨트롤러를 단순하게 하지만 도메인 모델의 테스트 유의성이 떨어진다.
3. 의사 결정 프로세스 단계를 더 세분화하기 : 성능과 도메인 모델 테스트 유의성에 도움을 주지만, 컨트롤러가 단순하지 않다. 이러한 세부 단계를 관리하려면 컨트롤러에 의사 결정 지점이 있어야 한다.


<img src = "https://www.kimcoder.io/assets/images/unit-testing-27.jpg"><br/>
위의 세 가지 특성을 모두 충족하는 해법은 없다.    
대부분의 소프트웨어 프로젝트에서는 성능이 매우 중요하므로 첫 번째 방법은 고려할 필요가 없다.  
두번째 옵션(도메인 모델에 프로세스 외부 의존성 주입하기)은 대부분 코드를 지나치게 복잡한 사분면에 넣는다.   
이러한 코드는 테스트와 유지 보수가 훨씬 어려워지므로 이러한 방법은 피하는 것이 좋다.  
세 번쨰 옵션(의사 결정 프로세스 단계를 더 세분화하기)는 컨트롤러를 더 복잡하게 만들지만, 이를 완화 할 수 있는 방법이 있다.  

**컨트롤러 복잡도 증가를 완화 시킬수 있는 방법**
- CanExecute/Execute 패턴 사용  
비즈니스 로직이 도메인 모델에서 컨트롤러로 유철하는 것을 방지하는 것이다.  
Do 메서드에 CanDo()를 두고 CanDo()가 성공적으로 실행되는 것을 Do()의 전제 조건으로 한다.  
이 패턴은 Do()전에 CanDo()를 호출하지 않을 수 없기 때문에 컨트롤러의 의사 결정을 근본적으로 제거한다.

예) 이메일은 사용자가 확인 할때 까지만 변경할수 있다고하자. 사용자가 확인한 후에 이메일을 변경하려고 하려면 오루메시작 표시되어야 한다.  
```
public string ChangeEmail(int userId, string newEmail) {

    if (user.IsEmailConfirmed) 
        "return "Can't change a confirmed email"; 

    user.ChangeEmail(newEmail, company);

    _database.SaveCompany(company);
    _database.SaveUser(user);
    _messageBus.SendEmailChangedMessage(userId, newEmail);
    return "OK";
}
```
- 이메일 변경 진행 여부(컨트롤러에서 수행)
- 변경시 해야할일 (User에서 수행)

CanExecute/Execute 패턴활용
```
public string CanChangeEmail()
{
    if (IsEmailConfirmed)
        return "Can't change a confirmed email";
    return null;
}
public void ChangeEmail(string newEmail, Company company)
{
    Precondition.Requires(CanChangeEmail() == null);
    /* the rest of the method */
}
```
컨트롤러는 더 이상 이메일 변경 프로세스를 알 필요가 없어졌다.
유효성 검사가 컨트롤러로부터 캡슐화 되었다.  
ChangeEmail의 전제 조건이 추가되어도 먼저 확인하지 않으면 이메일을 변경할 수 없도록 보장된다.

- 도메인 이벤트  
도메인 모델의 중요한 변경사항을 추적하고 해당 변경 사항을 프로세스 외부 의존성에 대한 호출로 변환한다.  
예) 메시지 버스에 메시지를 보내서 외부 시스템에 변경된 사용자 이메일을 알려줘야한다.  
이메일이 변경 될떄 이벤트를 추가하는 User
```
public void ChangeEmail(string newEmail, Company company) {
// 기존 작업 수행하고 이메일일 변경 완료 작업

EmailChangedEvents.Add(
    new EmailChangedEvent(UserId, newEmail));
}
```
도메인 이벤트를 처리하는 컨트롤러
```
public string ChangeEmail(int userId, string newEmail){

    // 컨트롤러 작업 생략
        
    foreach (var ev in user.EmailChangedEvents)
    {
        _messageBus.SendEmailChangedMessage(
            ev.UserId, ev.NewEmail); // 도메인 이벤트 처리
    }
    
    return "OK";
}
```
도메인 이벤트는 컨트롤러에서 의사 결정 책임을 제거하고 해당 책임을 도메인 모델에 적용함으로써  
외부 시스템과의 통신에 대한 단위 테스트를 간결하게 한다.  
컨트롤러를 검증하고 프로세스 외부 의존성을 목으로 대체하는 대신 단위 테스트에서 직접 도메인 이벤트 생성으로 테스트 할 수 도 있다.

추상화 할 것을 테스트하기보다는 추상화를 테스트하는 것이 더 쉽다.  
도메인 이벤트는 프로세스 외부 의존성 호출 위의 추상화에 해당한다.

### 7.5 결론
컨트롤러에 비즈니스 로직이 있는 것을 피할 수 없는 것처럼, 도메인 클래스에서 모든 협력자를 제거할 수 있는 경우는 거의 없을 것이다.  
프로세스 외부 의존성을 참조하지 않는 한 협력자가 여러개인 것은 지나치게 복잡한 코드가 아닐 것이다.  
그러나 이와 같은 협력좌와의 상호작용을 검증하려고 목을 사용하지는 말자.  
어러한 상호작용이 도메인 모델의 실별할 수 있는 동작과 아무런 관련이 없기 때문이다.  

식별할 수 있는 동작 
- 클라이언트 목표 중 하나에 직접적인 연관이 있음
- 외부 애플리케이션에서 볼 수 있는 프로세스 외부 의존성에서 사이드 이펙트가 발생함

식별할 수 있는 동작과 구현 세부 사항을 양파의 여러 겹으로 생각하라.  
외부 계층의 관점에서 각 계층을 테스트하고, 해당 계층이 기저 계층과 어떻게 통신하는지는 무시하라.  



