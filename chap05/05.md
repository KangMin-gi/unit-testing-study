# 5장

## 목과 테스트 취약성

- 목과 스텁 구분
- 식별할 수 있는 동작과 구현 세부 사항 정의
- 목과 테스트 취약성 간의 관계 이해
- 리팩터링 내성 저하 없이 목 사용하기

## 5.1 목과 스텁 구분

Mock : 테스트 대상 시스템과 협력자 사이의 상호 작용을 검사할 수 있는 테스트 대역이다.

### 5.1.1 테스트 대역 유형

테스트 대역 :

- 테스트를 편리하게 하기 위한 모든 유형의 비운영용 가짜 의존성. 실제 의존성 대신 전달되므로 설정이나 유지보수가 어려울수 있다.
- 더미, 스텁, 스파이, 목, 페이크등 다섯가지로 구분할 수 있지만 실제로는 목과 스텁의 두 가지 유형으로 나눌 수 있다.

![Untitled.png](img%2FUntitled.png)

- 둘의 차이점 : [https://martinfowler.com/articles/mocksArentStubs.html](https://martinfowler.com/articles/mocksArentStubs.html)
    - Mock : 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움이 된다.  SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당
        - 실제 객체의 동작을 모방하기 때문에 Mock **객체는 테스트 중인 코드의 동작을 변경하는 경우 잠재적으로 부작용을 일으킬 수 있습니다.**
    - Stub : 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다. SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당
        - 스텁 개체는 메서드 호출에 미리 결정된 응답을 제공하는 테스트 대역이다. 테스트에서 스텁 객체를 사용할 때 일반적으로 특정 메서드가 호출될 때 특정 값을 반환하거나 특정 예외를 throw하도록 개체를 설정합니다.

  ![이메일 발송은 SMTP 서버에 사이드 이펙트를 초래하는 상호 작용, 즉 외부로 나가는 상호 작용이며 목은 이러한 상호 작용을 모방하는 테스트 대역에 해당한다. DB에서 데이터를 검색하는 것은 내부로 들어오는 상호 작용이며 사이드 이펙트를 일으키지 않는 Stub이다.](5%E1%84%8C%E1%85%A1%E1%86%BC%2058298f3da7274fae923c6d207f4adb91/Untitled%201.png)

  이메일 발송은 SMTP 서버에 사이드 이펙트를 초래하는 상호 작용, 즉 외부로 나가는 상호 작용이며 목은 이러한 상호 작용을 모방하는 테스트 대역에 해당한다. DB에서 데이터를 검색하는 것은 내부로 들어오는 상호 작용이며 사이드 이펙트를 일으키지 않는 Stub이다.

- Mock은 테스트 대상 시스템과 관련 의존성 간의 상호 작용을 모방하고 검사하지만, 스텁은 모방만 한다.

### 5.1.2 도구로서의 목과 테스트 대역으로서의 목

```java
public class TaxCalculator {
    private TaxRateService taxRateService;

    public TaxCalculator(TaxRateService taxRateService) {
        this.taxRateService = taxRateService;
    }

    public double calculateTax(double income) {
        double taxRate = taxRateService.getCurrentTaxRate();
        return income * taxRate;
    }
}

public interface TaxRateService {
    public double getCurrentTaxRate();
}

public class StubTaxRateService implements TaxRateService {
    public double getCurrentTaxRate() {
        return 0.25;
    }
}

public class TaxCalculatorTest {
    @Test
    public void testCalculateTax() {
        TaxRateService stubTaxRateService = new StubTaxRateService();
        TaxCalculator taxCalculator = new TaxCalculator(stubTaxRateService);
        double tax = taxCalculator.calculateTax(10000);
        assertEquals(2500, tax, 0.01);
    }
}
```

```java
public class OrderService {
    private PaymentService paymentService;

    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    public boolean placeOrder(Order order) {
        double total = order.getTotal();
        boolean paymentSuccessful = paymentService.processPayment(total);
        if (paymentSuccessful) {
           
            return true;
        } else {
            return false;
        }
    }
}

public interface PaymentService {
    public boolean processPayment(double amount);
}

public class MockPaymentService implements PaymentService {
    private boolean expectedPaymentResult;

    public MockPaymentService(boolean expectedPaymentResult) {
        this.expectedPaymentResult = expectedPaymentResult;
    }

    public boolean processPayment(double amount) {
        return expectedPaymentResult;
    }
}

public class OrderServiceTest {
    @Test
    public void testPlaceOrderWithSuccessfulPayment() {
        PaymentService mockPaymentService = new MockPaymentService(true);
        OrderService orderService = new OrderService(mockPaymentService);
        Order order = new Order(...);
        boolean orderPlaced = orderService.placeOrder(order);
        assertTrue(orderPlaced);
    }

    @Test
    public void testPlaceOrderWithFailedPayment() {
        PaymentService mockPaymentService = new MockPaymentService(false);
        OrderService orderService = new OrderService(mockPaymentService);
        Order order = new Order(...);
        boolean orderPlaced = orderService.placeOrder(order);
        assertFalse(orderPlaced);
    }
}
```

### 5.1.3 스텁으로 상호 작용을 검증하지 말라

- SUT에서 스텁으로의 호출은 SUT가 생성하는 최종 결과가 아니라 최종 결과를 산출하기 위한 수단일 뿐이다. 스텁은 SUT가 출력을 생성하도록 입력을 제공하는것이다.
-

### 5.1.4 목과 스텁 함께 쓰기

### 5.1.5 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?

![Untitled](img%2FUntitled%202.png)

- 목과 스텁의 개념은 명령 조회 분리원칙(Command Query Separation)과 관련이 있다.
    - 모든 메서드는 명령이거나 조회이다.
        - 명령 : 사이드 이펙트를 일으키고 반환값이 없다.
            - 사이드 이펙트 : 객체 상태 변경, 파일 시스템 내 파일 변경
        - 조회 : 사이드 이펙트가 없고 반환값이 있다.
            - 스택의 pop은 조회이지만 사이드 이펙트가 있다.

## 5.2 식별할 수 있는 동작과 구현 세부 사항

- 테스트는 ‘어떻게’가 아닌 ‘무엇’에 집중해야 한다.
- 식별할 수 있는 동작은 결국 어떤 입력값을 메서드에 전달했을때 예상되는 반환값들을 말한다.

### 5.2.1 식별할 수 있는 동작은 공개 API와 다르다

모든 제품 코드는 2차원으로 분류할 수 있다.

- 공개 API , 비공개 API
- 식별할 수 있는 동작, 구현 세부 사항

코드가 시스템의 식별할 수 있는 동작인 경우 다음 두가지 중 하나를 만족해야 한다.

1. 클라이언트가 목표를 달성하는 데 도움이 되는 연산(operation)을 노출. 연산은 계산을 수행하거나 사이드 이펙트를 초래하거나 둘 다 하는 메서드이다.
2. 클라이언트가 목표를 달성하는 데 도움이 되는 상태(state)를 노출. 상태는 시스템의 현재 상태이다.

그에 반해 구현 세부 사항은 위 두 가지 중 아무것도 하지 않는다.

코드가 식별할 수 있는 동작인지 여부는 해당 클라이언트가 누구인지, 그리고 해당 클라이언트의 목표가 무엇인지에 달려 있다.

식별할 수 있는 동작이 되기 위해서는 이런 목표가 무엇인지에 달려 있다.

클라이언트라는 단어는 코드가 있는 위치에 따라 다른 것을 의미할 수 있다.

- 동일한 코드베이스
- 외부 애플리케이션
- 사용자 인터페이스

이상적으로 시스템의 공개 API는 식별할 수 있는 동작과 일치해야 하며, 모든 구현 세부 사항은 클라이언트 눈에 보이지 않아야 한다.

![Untitled](img%2FUntitled%203.png)

그러나 종종 시스템의 공개 API가 식별할 수 있는 동작의 범위를 넘어 구현 세부 사항을 노출하기 시작한다. 이러한 시스템의 구현 세부 사항은 공개 API로 유출된다.

![Untitled](img%2FUntitled%204.png)

### 5.2.2 구현 세부 사항 유출 : 연산의 예

예제 5.5 에서 유저 컨트롤러는 public api는 observable behaviour를 넘어 implementation detail을 노출시켰다 (user.NormailizeName(newName);)

유저 컨트롤러에서는 유저 이름을 Normalize하는 과정을 알아서는 안된다.

```java
public class User {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = normalizeName(name);
    }

    private String normalizeName(String name) {
        String result = (name != null ? name : "").trim();
        if (result.length() > 50) {
            return result.substring(0, 50);
        }
        return result;
    }
}

public class UserController {
    public void renameUser(int userId, String newName) {
        User user = getUserFromDataBase(userId);
        user.setName(newName);
        saveUserToDataBase(user);
    }
}
```

클래스가 구현 세부 사항을 유출하는지 판단하는 데 도움이 되는 유용한 규칙

- 단일한 목표를 달성하고자 클래스에서 호출해야 하는 연산의 수가 1보다 크면 해당 클래스에서 구현 세부 사항을 유출하고 있을 가능성이 높다.

### 5.2.3 잘 설계된 API와 캡슐화

- 불변성 위반으로 구현 세부 사항을 노출하게 된다.
    - 예제 5.5 에서 클라이언트는 그냥 ‘_name’ 필드에 다이렉트로 값을 할당하여불변성을 우회하고 정규화 하지 않은 이름을 할당 할 수 있었다.

    ```java
    User user = new User();
    user._name = "John Doe"; 
    ```

- 코드베이스 유지 보수에서는 캡슐화가 중요하다.
    - 코드베이스가 복잡해질수록 작업하기가 더 어려워지고, 개발 속도가 느려지며, 버그 수가 증가한다.
- 코드 API가 해당 코드로 할 수 있는 것과 할 수 없는 것을 알려주지 않으면 코드가 변경 됐을 때 모순이 생기지 않도록 많은 정보를 염두에 둬야 한다.
- 캡슐화를 올바르게 유지해 실수 할 가능성을 줄여야한다.
- Tell Don’t Ask [https://martinfowler.com/bliki/TellDontAsk.html](https://martinfowler.com/bliki/TellDontAsk.html)
    - 데이터를 연산 기능과 결합하는 것

- 구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다.
- 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.

### 5.2.4 구현 세부 사항 유출 : 상태의 예

- 모든 구현 사항을 비공개로 하면 테스트가 식별할 수 있는 동작을 검증하는 것 외에는 다른 선택지가 없어지며 리팩터링 내성도 좋아진다.
- 연산과 상태를 최소한으로 노출해야한다.
    - 클라이언트가 목표를 달성하는 데 직접적으로 도움이 되는 코드만 공개해야 하고 다른 모든 것은 구현 세부 사항이므로 비공개 API 뒤에 숨긴다.

|  | 식별할 수 있는 동작 | 구현 세부 사항 |
| --- | --- | --- |
| 공개 | 좋음 | 나쁨 |
| 비공개 | 해당 없음 | 좋음 |

## 5.3 목과 테스트 취약성 간의 관계

### 5.3.1 육각형 아키텍처 정의

전형적인 애플리케이션은 그림 5.8과 같이 도메인과 애플리케이션 서비스라는 두 계층으로 구성

- 도메인 계층은 애플리케이션의 중심부.
    - 애플리케이션의 필수 기능으로 비즈니스 로직이 포함되어 있다.
    - 도메인 계층과 비즈니스 로직은 이 애플리케이션을 다른 애플리케이션과 차별화하고 조직의 경쟁력을 향상시킨다.

![Untitled](img%2FUntitled%205.png)

애플리케이션 서비스 계층은 도메인 계층 위에 있으며 외부 환경과의 통신을 조정한다.

- 애플리케이션이 RESTful API인 경우 API에 대한 모든 요청이 먼저 애플리케이션 서비스 계층에 도달한다.
- 애플리케이션 서비스 계층은 도메인 클래스와 프로세스 외부 의존성 간의 작업을 조정한다.
- 애플리케이션 서비스에 대한 조정의 예시 :
    - 데이터베이스를 조회하고 해당 데이터로 도메인 클래스 인스턴스 구체화
    - 해당 인스턴스에 연산 호출
    - 결과를 DB에 다시 저장

애플리케이션 서비스 계층과 도메인 계층의 조합은 육각형을 형성하며, 이 육각형은 애플리케이션을 나타낸다.

- 또한 다른 애플리케이션 역시 육각형으로 나타내는데 여기서 말하는 다른 애플리케이션이란 SMTP 서비스, 서드 파티 시스템, 메시지 버스 등이 될 수 있다.
- 여러 육각형이 서로 소통하며 육각형 아키텍처를 구성한다.

![Untitled](img%2FUntitled%206.png)

육각형 아키텍처라는 용어는 세가지 중요한 지침을 강조한다.

1. 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리 :
    1. 비즈니스 로직은 애플리케이션의 가장 중요한 부분이기에 도메인 계층은 해당 비즈니스 로직에 대해서만 책임을 져야 하며 다른 책임에서는 제외되어야 한다.
    2. 외부 애플리케이션과의 통신, DB 검색등과 같은 책임은 애플리케이션 서비스에 귀속되어야 하며 어떤 비즈니스 로직도 애플리케이션 서비스 계층에 있어서는 안된다.
        1. 요청이 들어오면 도메인 클래스의 연산으로 변환하고 다음 결과를 저장하거나 호출자에게 반환해 도메인 계층으로 변환하는 책임이 있다.
    3. 도메인 계층을 애플리케이션의 도메인 지식(사용 방법) 모음으로
    4. 애플리케이션 서비스 계층을 일련의 비즈니스 유스케이스(사용 대상)로 볼 수 있다.
2. 애플리케이션 내부 통신 :
    1. 육각형 아키텍처는 애플리케이션 서비스 계층에서 도메인 계층으로 흐르는 단방향 의존성 흐름을 규정한다.
        1. 도메인 계층 내부 클래스는 도메인 계층 내부 클래스끼리 서로 의존하고 애플리케이션 서비스 계층의 클래스에 의존하지 않는다.
        2. 애플리케이션 서비스 계층과 도메인 계층 간에 관심사를 분리하는 것은 애플리케이션 서비스 계층이 도메인 계층에 대해 아는 것을 의미하지만, 반대는 아니다.
        3. 도메인 계층은 외부 환경에서 완전히 격리되어야 한다.
3. 애플리케이션 간의 통신 :
    1. 외부 애플리케이션은 애플리케이션 서비스 계층에 있는 공통 인터페이스를 통해 해당 애플리케이션에 연결되며 그 누구도 도메인 계층에 직접 접근할 수 없다.
    2. 육각형의 각 면은 애플리케이션 내외부 연결을 나타낸다.
        1. 오직 6개만 연결할 수 있다는 뜻은 아니다.

애플리케이션의 각 계층은 식별할 수 있는 동작을 나타내며 해당 구현 세부 사항을 포함한다.

- 도메인 계층의 식별할 수 있는 동작은 이 계층의 연산과 상태
    - 연산과 상태는 애플리케이션 서비스 계층이 적어도 하나의 목표를 달성하는 데 도움이 된다.
- 잘 설계된 API 원칙에는 프랙탈 특성이 있다.

프랙탈 구조를 가지기 시작하면

- 달성하는 목표는 같지만 서로 다른 수준에서 동작을 검증한다.
    - 애플리케이션 서비스를 다루는 테스트는 해당 서비스가 외부 클라이언트에게 매우 중요하고 큰 목표를 어떻게 이루는지 확인
    - 도메인 클래스 테스트는 그 큰 목표의 하위 목표를 검증

어떤 테스트든 비즈니스 요구 사항으로 거슬러 올라갈 수 있어야 한다.

- 각 테스트는 도메인 전문가에게 의미 있는 이야기를 전달해야 하는데 그렇지 못한다면 테스트가 구현 세부 사항와 결합돼 있으므로 불안정하다는 강한 암시이다.

식별할 수 있는 동작은 바깥 계층에서 안쪽으로 흐른다.

- 외부 클라이언트에게 중요한 목표는 개별 도메인 클래스에서 달성한 하위 목표로 변환된다.
    - 즉 도메인 계층에서 식별할 수 있는 동작은 각각 구체적인 비즈니스 유스케이스와 연관성이 있다.

![Untitled](img%2FUntitled%207.png)

### 5.3.2 시스템 내부 통신과 시스템 간 통신

일반적인 애플리케이션에는 시스템 내부(inter-system)통신과 시스템 간(intra-system)통신이 있다.

- 시스템 내부 통신 : 애플리케이션 내 클래스 간 통신
- 시스템 간 통신 : 애플리케이션이 다른 애플리케이션과 통신하는 것

![Untitled](img%2FUntitled%208.png)

연산을 수행하기 위한 도메인 클래스 간의 협력은 식별할 수 있는 동작이 아니므로 시스템 내부 통신은 구현 세부 사항에 해당한다.

- 이러한 협력은 클라이언트의 목표와 직접적인 관계가 없다. 따라서 이러한 협력과 결합하면 테스트가 취약해진다.

애플리케이션 내부의 클래스 간 협력과 달리 시스템 외부 환경과 통신하는 방식은 전체적으로 해당 시스템의 식별할 수 있는 동작을 나타내며 애플리케이션에 항상 있어야 하는 계약이다.

시스템 간 통신의 특성은 별도 애플리케이션과 함께 성장하는 방식에서 비롯된다

- 성장의 주요 원칙 중 하나로 하위 호환성을 지키는 것이다.
- 시스템 내부에서 하는 리팩터링과는 달리, 외부 애플리케이션과 통신할 때 사용하는 통신 패턴은 항상 외부 애플리케이션이 이해할 수 있도록 유지해야 한다.
    - 예) 애플리케이션이 메시지 버스로 전송하는 메시지는 구조를 지키고, SMTP 서비스 호출은 매개변수의 유형과 개수 등을 맞춘다.

![Untitled](img%2FUntitled%209.png)

목을 사용하면 시스템과 외부 애플리케이션 간의 통신 패턴을 확인할 때 좋다.

- 반대로 시스템 내 클래스 간 통신 검증에 사용하면 테스트가 구현 세부 사항과 결합되고 리팩터링 내성이 떨어진다.

### 5.3.3 시스템 내부 통신과 시스템 간 통신의 예

비즈니스 유스케이스

- 고객이 상점에서 제품을 구매하려 한다
- 매장 내 제품 수량이 충분하면
    - 재고가 상점에서 줄어든다
    - 고객에게 이메일로 영수증을 발송한다.
    - 확인 내역을 반환한다.

애플리케이션은 UI가 없는 API라고 가정

Purchase 메서드에서 고객은 상점 재고가 충분한지 확인 후, 제품 수량 감소

구매라는 동작은 시스템 내부 통신과 시스템 간 통신이 모두 있는 비즈니스 유스케이스이다.

- 시스템 간 통신 : CustomerController 애플리케이션의 서비스와 두 개의 외부 시스템인 서브파티 애플리케이션과 이메일 게이트웨이 간의 통신
- 시스템 내부 통신 : Customer와 Store 도메인 클래스 간의 통신

SMTP 서비스에 대한 호출은 외부 환경에서 볼 수 있는 사이드 이펙트이므로 애플리케이션에 전체적으로 식별할 수 있는 동작을 나타낸다.

- 또한 고객의 목표에 직접적인 연관이 있다.
- 애플리케이션의 클라이언트는 서드파티 시스템이다. 해당 시스템의 목표는 구매를 하는 것이며, 고객이 성공적인 결과로서 이메일로 확인 내역을 받는 것을 기대한다.

![Untitled](img%2FUntitled%2010.png)

SMTP 서비스에 대한 호출을 목으로 하는 이유

- 리팩터링 이후에도 이러한 통신 유형이 그대로 유지되도록 하기 때문에 테스트 취약성을 야기하지 않기 때문.

## 5.4 단위 테스트의 고전파와 런던파 재고

|  | 격리 주체 | 단위의 크기 | 테스트 대역 사용 대상 |
| --- | --- | --- | --- |
| 런던파 | 단위 | 단일 클래스 | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성 |
- 런던파는 불변 의존성을 제외한 모든 의존성에 목을 권장하며 `시스템 내 통신`과 `시스템 간 통신`을 구분하지 않기 때문에 애플리케이션 외부 시스템 간의 통신을 확인하는 것처럼 클래스 간 통신까지 확인한다.
- 런던파를 따라 목을 무분별하게 사용하면 종종 구현 세부 사항에 결합되어 테스트에 리팩터링 내성이 사라지고 테스트의 가치가 사라진다.
- 이에 반해 고전파는 테스트 간 공유하는 의존성만 교체하므로 이 문제에 훨씬 유리하지만 시스템 간 통신에 대한 처리에 이상적이지는 않다.
    - 고전파도 런던파 못지않게 목 사용을 지나치게 장려한다.

### 5.4.1모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다

의존성의 유형

- 공유 의존성 : 테스트 간 공유하는 의존성 (제품 코드가 아니다)
- 프로세스 외부 의존성 : 프로그램 실행 프로세스 외에 다른 프로세스를 점유하는 의존성 (데이터베이스, 메시지 버스, SMTP등)
- 비공개 의존성 : 공유하지 않는 모든 의존성

고전파에서는 공유 의존성을 피할 것을 권고한다.

- 테스트가 실행 컨텍스트를 서로 방해하고 결국 병렬 처리를 할 수 없기 때문이다.
- 테스트를 병렬적, 순차적 또는 임의의 순서로 실행할 수 있는 것을 테스트 격리라 부른다.

공유 의존성이 프로세스 외부에 있는것이 아니라면 각 테스트 실행 시 해당 의존성을 새 인스턴스로 써서 재사용을 피할 수 있지만,

프로세스 외부에 있는 경우는 좀 더 복잡하다.

- 각 테스트 실행 전에 데이터베이스를 인스턴스화 하거나 메시지 버스를 새로 준비할 수가 없다.
- 이러한 의존성을 테스트 대역인 목과 스텁으로 교체하는 것이 일반적이다.

다만 모든 외부 의존성을 목으로 해야 하는 것은 아니다.

- 프로세스 외부 의존성이 애플리케이션을 통해서만 접근할 수 있으면, 이러한 의존성과의 통신은 시스템에서 식별할 수 있는 동작이 아니다.
- 외부에서 관찰할 수 없는 프로세스 외부 의존성은 애플리케이션의 일부로 작용한다.

애플리케이션과 외부 시스템 간의 통신 패턴을 항상 지켜야 하는 요구 사항은 하위 호환성을 지켜야 한다는 점에서 비롯된다.

- 애플리케이션이 외부 시스템과 통신하는 방식을 지켜야 한다.
- 애플리케이션과 외부 시스템을 동시에 변경할 수 없기도 하고, 배포 주기가 다르거나 단순히 제어 권한이 없을 수 있기 때문이다.

![Untitled](img%2FUntitled%2011.png)

그러나 애플리케이션이 외부 시스템에 대한 프록시 같은 역할을 하고 클라이언트가 직접 접근할 수 없으면, 하위 호환성 요구 사항은 사라지게 된다.

- 외부 시스템과 애플리케이션을 같이 배포할 수 있으면 클라이언트에 영향을 미치지 않는다.
- 이러한 시스템의 통신 패턴은 구현 세부 사항이 된다.

예를 들자면 애플리케이션에서만 사용되는 데이터베이스

- 어떤 외부 시스템도 이  DB에 접근 할 수 없기 때문에 기존 기능을 손상시키지 않는 한 시스템과 애플리케이션 데이터베이스 간의 통신 패턴을 원하는 대로 수정할 수 있다.
- 해당 DB는 클라이언트의 시야에서 완전히 숨어있기 때문에 전혀 다른 저장 방식으로 대체되어도 아무도 모른다.

완전히 통제권을 가진 프로세스 외부 의존성에 목을 사용하면 깨지기 쉬운 테스트가 된다.

- DB와 애플리케이션은 하나의 시스템으로 취급해야 한다.

### 5.4.2 목을 사용한 동작 검증

- 종종 목이 동작을 검증한다고 하지만 그렇지 않다.
    - 목표를 달성하고자 각 개별 클래스가 이웃 클래스와 소통하는 방식은 식별할 수 있는 동작과는 아무런 관계가 없으며 이는 구현 세부 사항이다.
- 클래스 간 통신을 검증하는 것은 두뇌의 뉴런이 서로 통과하는 신호를 측정해 사람의 행동을 유추하는 것과 비슷하다. 즉 너무 세밀하다.
- 중요한 것은 클라이언트 목표로 거슬러 올라갈 수 있는 동작
- 클라이언트가 도움을 청할 때 중요한 것은 도움 뿐이다.
- 목은 애플리케이션의 경계를 넘나드는 상호 작용을 검증할 때와 이러한 상호 작용 사이드 이펙트가 외부 환경에서 보일 때만 동작과 관련이 있다.