## 좋은 단위테스트

---
### 기본 전제 및 용어정리
 - 좋은 테스트 스위트는 개발주기 통합, 중요한 부분만을 대상, 최소 유지비 최대가치
 - 좋은 테스트를 짜려면, 좋은 테스트가 뭔지부터 알아야한다 (기존 테스트를 보고 식별할 수 있어야함)
 - 거짓양성 : 기능고장은 아닌데, 테스트가 실패
 - 거짓음성 : 기능고장인데, 테스트가 성공
### 여기선 좋은 테스트가 뭔지 식별하는 법에대해 본다.

---

### 좋은 테스트의 4대 요소
 - 회귀 방지 (버그를 방지)
 - 리팩터링 내성 (리팩터링에도 얼마나 테스트가 안뿌서지나)
 - 빠른 피드백 (테스트 스윗의 빠른 실행과 동일)
 - 유지 보수성 

---

### 회귀 방지
 - <b>버그 방지</b>
 - 코드가 커질수록, 버그가 많아질 수 밖에 없어서 이를 보호하는 방법이 중요
 - 테스트가 얼마나 버그를 잘 방지하고 있는지에 대한 척도
   - 테스트 중 실행하는 코드의 양 : 당연히 버그를 잡을 가능성이 높아짐
   - 코드 복잡도 : 복잡한 코드를 테스트하고 있는가? 인듯
     - 단순한 코드는 버그발생이 거의 없어서, 당연히 복잡한 코드를 테스트하는게 더 좋다
     - 로직이 그다지 없는, getter/setter 를 테스트 하지않는 이유
   - 코드와 도메인의 유의성 : 도메인과 얼마나 붙은 코드인가, 즉 코드의 중요성에 대해 말하는듯
     - 코드가 얼마나 중요한가? 에 대한 가치를 말하는것 같다. 
 - 우리가 작성하지 않은 코드도 중요하다.
   - 외부 라이브러리나 외부 시스템도 회귀발생에 중요하다.
   - 오픈소스 라이브러리나, 외부 시스템의 정합도도 내가 테스트를 해야하는건가..?
 - <b>버그방지를 극대화 하는건, 많은 코드를 실행하는게 가장 좋다</b>
   - 높은 테스트 커버리지?

---
### 리팩터링 내성 과 거짓양성 이야기
 - <B>거짓양성 없이, 얼마나 리팩터링 할 수 있는가</b>
 - 중요한 이유
   - 단위 테스트의 목적은 프로젝트 성장을 지속 가능하게 하는 것
     - 이는 주기적으로 리팩터링/기능추가 가 가능하기 때문
     - 기능 고장에 대해 경고를 제공해서, 배포하기 전 문제 해결 가능
     - 코드 변경이 버그가 없을것이라는 개발자에게 확신을 준다 (제일 좋은듯)
 - <B>거짓 양성은 위의 중요한 이유를 전부 방해한다</b>
   - ```테스트에 대한 신뢰 하락```
     - 양치기 소년에 비교할 수 있다.
     - 항상 빨간불을 외치지만, 우리는 거짓 양성인 줄 알고 점점 무시하게 되는 경향
     - 여기에서 버그가 생기면, 앞으로 테스트를 믿을 수 없어 리팩토링 자체를 포기하게 되는 경우로 발전
   - 상세 예시는 하단에
 - 거짓 양성의 원인
   - 거짓양성은 구현의 세부사항과 많이 결합되면 생기게 된다
   - 일례로, html을 반환하는 코드를 테스트 한다고 하자. 이상한 함수지만 극단적 예시를 위한것뿐
 ```java

public class HtmlMakerWrapper {

    private List<HtmlMaker> htmlList = Arrays.asList(
            new HeaderMaker(), // public String make(String message) { return "<Header>" + v + " </header>"; }
            new BodyMaker(), // public String make(String message) { return "<Body>" + message + " </body>"; }
            new FooterMaker() // public String make(String message) { return "<footer>" + message + " </footer>"; }
    );

    public List<HtmlMaker> list() {
        return this.htmlList;
    }

    public String allMake(String message) {
        return htmlList.forEach(v -> v.make(message));
    }

    @Test
    public void 구현과_결합된_나쁜방법() {
        HtmlMakerWrapper w = new HtmlMakerWrapper();
        List<HtmlMaker> list = w.list();
        assertThat(list.get(0)).isInstanceOf(HeaderMaker.class);
        assertThat(list.get(1)).isInstanceOf(BodyMaker.class);
        assertThat(list.get(2)).isInstanceOf(FooterMaker.class);
    }
    
    @Test
    public void 좋은예_인가() {
        HtmlMakerWrapper w = new HtmlMakerWrapper();
        String msg = "b";
        String ret = w.allMake(msg);
        assertThat(ret).contains("<html>${msg}</html>").and()
                .contains("<body>${msg}</body>").and()
                .contains("<footer>${msg}</footer>");
        /// 요론 느낌으로 해야하나
    }
}
```
 - 간단한 예시코드이다. 테스트가 도대체 안에서 어떤 구현체로 돌아가는지 알아야 할 필요는 무엇인가?
 - 안의 구현체가 바뀌거나, 아예 저런식으로 하지 않으면 문제가 될 수 있다.
 - 평소에 ```Exception``` 의 instanceOf도 많이 테스트 하는데, 이것도 그런 종류일까?
 - Parameter가 변경해서 오류 나는것도 거짓 양성이다.
   - 좀 심한거 같다
   - 컴파일 오류가 나기 때문에, 해결 하기 쉬움


### 회귀 방지와 리팩토링 내성
 - 프로젝트가 시작된 직후는 회귀방지가 중요하지만 리팩토링 내성은 바로 필요하지 않다.
   - 거짓 양성이 본격적으로 나빠지는건, 프로젝트 초반보다는 후반부에 심해진다
   - 위의 예시처럼 점점 커져서 리팩토링이 필요해 지는 순간에는, 치명적으로 다가오게 된다.
   - 초기에는 거짓빨간불도, 구현 기억이 있고 코드가 작아 쉽게 찾을수 있어 신뢰도 하락이 적어서 그런듯 하다
   - 대부분의 단위 테스트는, 회귀에만 집중하는데 멀리 보고 중요한 테스트는 리팩토링 내성도 굉장히 중요하다
     - 나도 회귀말곤 솔직히 신경쓴 적이 없다.
 - 회귀 방지는 거짓 음성에 대해 예방
 - 리팩터링 내성은 거짓 양성에 대해 예방


### 나머지 두 속성
 - 빠른 피드백 : 실행 속도 와 실행 주기를 결합한 느낌으로 보면 될것같더라
   - 테스트가 빠르게 실행되면 버그를 금방금방 고칠 수 있다.
 - 유지 보수성 : 테스트가 정말 길고 복잡하면, 이해하는게 굉장히 어려워진다.
   - 테스트를 작성할 때 절차를 생략하지 말라. 일급 시민으로 취급하라
     - ```무슨말일까, 중요한 친구로 생각하라는 건가?```
   - 테스트 실행이 어려우면 안된다
     - 외부 의존성에 의존하게 되면 실행하는데 시간이 많이든다 -> 결국 빠른피드백 불가

---
### 네가지 속성과, 이상적인 테스트
 - 네가지 속성 중 <b>하나가 0이면, 가치가 0!</b>
   - 테스트의 가치는 네가지 속성의 곱!
     - ```가치 = [0..1] * [0..1] *[0..1] * [0..1]```
     - 당연히 점수를 내는 건 어렵지만, 개념을 잡을 순 있다.
   - 가치가 0인 테스트의 극단적 예시
     - EndToEnd
       - Good : 회귀방지 (어마무시한 코드 실행) + 리팩토링 내성 (진입점만 테스트해서 높다)
       - Bad (0점) : 빠른 피드백 (외부 의존성 설정 등 너무 할게 많아진다)
     - Simple Test (ex. getter 테스트)
       - Good : 빠른 피드백 + 리팩터링 내성
       - Bad : 회귀 방지 (잡을 버그가 없는데..)
     - Brittle Test
       - 간단 설명 : findById(Long id) 를 테스트 하는데, 날아가는 쿼리를 String으로 비교해서 테스트 하는것.
       - Good : 회귀 방지 + 빠른 피드백
       - Bad : 리팩터링 내성 (쿼리 String은 언제든 변경될 수 있다. 모양이 약간 바뀌든 * 에서 컬럼 전체로 바뀌게 되면 오류가 나게됨 )
 - 이상적인 테스트를 만드는건 불가능
   - 회귀, 리팩토링, 빠른 피드백은 서로 상호 배타적이다.
   - CAP (일관성, 가용성, 분할내구성) 법칙과 비슷
   - 두가지를 극대화 하는 테스틀르 만들기는 쉽지만, 나머지 한가지를 희생해야함
 - <b>이중, 리팩토링 내성은 0 아니면 1이기 때문에, 언제나 들고가야함</b>
 - 나머지 두 특성인 ```회귀 방지, 빠른 피드백``` 사에이서 선택을 해야한다!

### 테스트 피라미드 에서의 요소 선택
 - 테스트 피라미드는 ```EndToEnd, 통합, 단위 테스트```를 피라미드 모양으로 배치
 - 어느 테스트도 리팩토링 내성을 포기하지 않는다!
 - 유지보수성은 EndToEnd는 어쩔수 없이 포기
   - 그래서 가장 적어야 한다
 - EndToEnd는 회귀 방지에 집중된 테스트 (빠른 피드백이 사실상 불가능 하다)
 - 통합 테스트는 회귀 방지와 빠른 피드백의 중간 
 - 단위 테스트는 빠른 피드백에 치중된 테스트 (회귀 방지는 코드실행이 적어 약해질 수 밖에 없다)

### 블랙 박스와 화이트 박스
 - 블랙박스 : 내부 구현없이 인, 아웃만을 검증
 - 화이트박스 : 내부 구현 자체를 검증 
 - 기본적으로 모든 테스트는 블랙박스 기준으로 작성.
 - 화이트박스는 테스트가 구현에 결합되어 테스트가 깨질 수 밖에 없어져서 그렇다.
 - 테스트를 분석할때는 커버리지를 이용해서 분기 실행 여부를 확인하고 (화이트 박스) , 테스트를 진행할 떄는 블랙박스로 진행하라

---

### 스터디 하면서 궁금증
 - 통합 테스트는 어느정도를 얘기하는 걸까.. 간단한 예시라도 있으면 좋겠따
 - EndToEnd는 통합 테스트의 일부 의존성을 어디까지 넣냐에 따라 달라진다.
 - 앞에서 예시로 든건 결제 게이트웨이, 결제 게이트웨이 같은 경우 제어할 수 없는데, ENDToEnd는 이부분 까지 테스트 대역이 아니라 실제로 변경한다.


