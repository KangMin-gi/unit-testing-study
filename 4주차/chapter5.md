# 5장  Mock과 테스트 취약성

### 5.1  목과 스텁 구분
테스트 대역은 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어다.  

테스트 대역의 2가지 유형
- 목: 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움이 된다.  
이러한 상호작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당한다.  
목은 SUT에서 관련 의존성으로 나가는 상호작용을 모방하고 검사한다.  


- 스텁: 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다.   
이러한 상호작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.  
스텁은 내부로 들오오는 상호작용만 모방하고 검사하지 않는다.  
테스트가 스텁과의 상호 작용을 확인해서는 안된다. -> 결합이라 표현함.  
<img src="https://enterprisecraftsmanship.com/images/2020/2020-04-13-incoming-outcoming.png"><br/>
이메일 발송은 SMTP 서버에서 사이드 이펙트를 초래하는 상호작용으로 외부로 나가는 상호작용이다. = 목  
데이터베이스에서 데이터를 검색하는 것은 내부로 들어오는 상호작용이다. = 스텁

**목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?**  
모든 메서드는 명령이거나 조회여야 한다. (명령 조회 분리, CQS, Command Query Separation)  
명령은 사이드 이펙트를 일으키고 어떤 값도 반환하지 않는다. (void 반환)  
조회는 사이트 이펙트가 없고 값을 반환한다.  
<img src="https://enterprisecraftsmanship.com/images/2020/2020-04-13-cqs.png"><br/>  
명령 조회 분리 원칙에서 명령은 목에 해당하고 조회는 스텁에 해당한다.    
물론 항상 명령 조회 분리 원칙을 따르는 것은 아니다.    

### 5.2 식별할 수 있는 동작과 구현 세부사항
Mock과 테스트 취약성 간의 연관성을 찾기 위한 다음 단계로, 이 취약성을 일으키는 원인을 알아보자.    
테스트 취약성은 좋은 단위 테스트의 두 번째 특성이 리팩토링 내성에 해당한다.   
테스트가 단위 테스트 영역에 존재하고, 엔드 투 엔드 테스트의 범주로 바뀌지 않는 한 리팩토링 내성을 최대한 활용하는 것이 좋다.    

리팩터링 내성에 실패하는 즉, 테스트에 거짓 양성이 있는 주요 원인은  
구현 세부 사항과의 결합이다.  
이런 결합을 피하는 방법은 코드가 생성하는 최종 결과(식별할 수 있는 동작)를 검증하고 구현 세부사항과 테스트를 가능한 떨어뜨리는 것이다.  
결과적으로 테스트는 “어떻게” 가 아니라 “무엇에” 중점을 두어야 한다.  

모든 제품 코드는 두 가지 범주로 분류할 수 있다.  
- 공개 API 또는 비공개 API
- 식별가능한 동작 또는 구현 세부 사항

만약 코드가 시스템에서 식별가능한 동작이라면 다음 중 하나에 해당되어야 한다.
- 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출해야 한다. 연산은 계산을 수행하거나 부작용을 초래하거나 둘 다 해당되는 메서드이다.  
- 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출해야 한다. 상태는 시스템의 현재 상태다.  


즉, 코드가 식별가능한 동작인지의 여부는 해당 클라이언트가 누구인지, 그리고 해당 클라이언트의 목표가 무엇인지에 달려있다.  
구현 세부사항은 이 두가지 중 아무것도 하지 않는다.    
<img src="https://drive.google.com/uc?export=view&id=1qYRq-4_PctrBu6bxi69ShyqMuiTDez7c"><br/>
이상적으로는 시스템의 공개 API는 식별가능한 동작과 일치해야 하며, 모든 구현 세부 사항은 클라이언트에게 노출되지 않아야 한다.  
<img src="https://drive.google.com/uc?export=view&id=1SfYDZqoSgVrUOfUJm0STD1HrF67QTmxM"><br/>
그러나 종종 시스템의 공개 API가 식별가능한 동작의 범위를 넘어 구현 세부 사항을 노출하는 경우가 있다.  
이때 시스템의 구현 세부 사항은 공개 API로 유출된다.  

**구현 세부 사항의 유출 : 연산의 예시**
요구사항으로 사용자 이름이 50자를 초과해서는 안되며, 초과하는 경우 초과하는 부분을 잘라야 한다는 불변 속성이 있다.
```
public class User {
    public string Name { get; set; }
    
    public string NormalizeName(string name) {
        string result = (name ?? "").Trim();
        if (result.Length > 50)
            return result.Substring(0, 50);
        return result;
    }
}

public class UserController {
    public void RenameUser(int userId, string newName) {
        User user = GetUserFromDatabase(userId);
        string normalizedName = user.NormalizeName(newName);
        user.Name = normalizedName;
        SaveUserToDatabase(user);
    }
}
```
UserController 클래스가 여기서 클라이언트의 역할을 하며, RenameUser() 메서드에서 User 클래스를 사용하다.  
이 메서드의 목표는 사용자의 이름을 변경하는 것이다.  
이름을 변경하기 위해 setter를 노출하고 있고 normalizedName은 클라이언트의 목표에 직결되지 않는다.  

개선한 코드
```
public class User {
    private string _name;
    public string Name {
        get => _name;
        set => _name = NormalizeName(value);
    }
    
    private string NormalizeName(string name) {
        string result = (name ?? "").Trim();
        if (result.Length > 50)
            return result.Substring(0, 50);
        return result;
    }
}

public class UserController {
    public void RenameUser(int userId, string newName) {
        User user = GetUserFromDatabase(userId);
        user.Name = newName;
        SaveUserToDatabase(user);
    } 
}
```
식별할 수 있는 동작 = Name 속성만 공개되고  
구현 세부 사항 = NormalizeName 메서드는 비공개 API로 숨겼다.  

**잘 설계된 API와 캡슐화**  
잘 설계된 API를 유지보수하는 것은 캡슐화 개념과 관련이 있다.  
코드베이스가 점점 복잡해질수록 작업하기 더 어려워지고, 개발 속도도 느려지고, 버그수도 증가한다.  
코드 복잡도에 대처할 수 있는 방법은 실질적으로 캡슐화 말고 없다.  
코드 캡슐화가 목표이지만 구현 세부 사항을 숨기고 데이터와 기능을 결합하기 해당 목표를 달성하기 위한 수단이다.  
- 구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다.  
- 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.  

### 5.3 목과 테스트 취약성 간의 관계
육각형 아키텍처  
<img src="https://drive.google.com/uc?export=view&id=116VOVs54O4ugnBYjuMKYRPRwoQrJ5FWA"><br/>
도메인 계층은 애플리케이션의 중심부에 있다.  
애플리케이션의 필수 기능으로 비즈니스 로직이 포함돼있다.  
애플리케이션 서비스는 비즈니스 유스케이스와 결합한다.  
애플리케이션 서비스에 대한 조정의 예시    
- 데이터베이스를 조회하고 해당 데이터로 도메인 클래스 인스턴스 구체화  
- 해당 인스턴스에 연산 호출  
- 결과를 데이터베이스에 다시 저장  


애플리케이션 서비스 계층과 도메인 계층의 조합은 육각형을 형셩하며 이 육각형은 애플리케이션을 나타낸다.  
또한 다른 애플리케이션과 소통할 수 있고, 다른 애플리케이션도 육각형으로 나타낸다.  
<img src ="https://drive.google.com/uc?export=view&id=1kzADilKIqvOgGlI3sAzGcGO8kQPM4iG-"><br/>

**육각형 아키텍처의 중요한 3가지 지침**  
1. 도메인 계층과 애플리케이션 서비스 계층 간의 관심사의 분리  
비즈니스 로직은 애플리케이션의 가장 중요한 부분으로, 도메인 계층은 비즈니스 로직에 대해서만 책임을 져야한다.  
다른 모든 책임에서는 제외돼야 한다.
애플리케이션 서비스에는 어떤 비즈니스 로직도 있으면 안된다. 
2. 애플리케이션 내부 통신  
   육각형 아키텍쳐는 애플리케이션 서비스 계층에서 도메인 계층으로 흐르는 단방향 의존성 흐름을 규정한다.  
   도메인 계층 내부 클래스는 도메인 계층 내부 클래스끼리 서로 의존하고, 애플리케이션 서비스 계층의 클래스는 의존하지 않는다.  

3. 애플리케이션 간의 통신  
   외부 애플리케이션은 애플리케이션 서비스 계층에 있는 공통 인터페이스를 통해 해당 애플리케이션에 연결된다.  
   아무도 도메인 계층에 직접 접근 할 수 없다.    

이처럼 계층을 분리하게 되면 아래와 같이 프랙탈 구조를 이루게 된다.  
<img src ="https://drive.google.com/uc?export=view&id=11_VC-i96cJtZJiVnN1a7clc8jfO63Xwl"><br/>
서로 다른 계층의 테스트는 동일한 동작을 서로 다른 수준으로 검증하는 프랙탈 특성이 있다.  
애플리케이션 서비스 테스트는 전반적으로 비즈니스 유스케이스가 어떻게 실행되는지 확인한다.  
도메인 클래스 테스트는 유스케이스 완료 방법에 대한 중간 하위 목표를 검증한다.   

코드베이스의 공개 API를 항상 비즈니스 요구 사항에 따르 추적하라는 이지 침은 대부분의 도메인 클래스와 애플리케이션 서비스에 적용되지만  
유틸리티나 인프라 코드에는 적용되지 않는다.

**시스템 내부 통신과 시스템 간 통신**  
<img src ="https://drive.google.com/uc?export=view&id=1oOijiGGuRdqc_4xTItpuGbTHp_ovLkXy"><br/>
시스템 내부 통신은 구현 세부 사항이고 시스템 간의 통신은 아니다.  
연산을 수행하기 위한 도메인 클래스 간의 협력은 식별할 수 있는 동작이 아니므로 시스템 내부 통신은 구현 세부 사항이다.  
이는 클라이언트 목표와 직접적인 관계가 없다. 이러한 협력과 결합하면 테스트가 취약해진다.  
시스템 간의 통신은 전테적으로 해당 시스템의 식별할 수 있는 동작을 나태낸다.  
외부 애플리케이션과 통신할 때 사용하는 통신 패턴은 항상 외부 애플리케이션이 이해할 수 있도록 유지해야 한다.  
예를 들어 애플리케이션이 메시지 버스로 전송하는 메시지는 구조를 지키고 SMTP 서비스 호출은 매개변수의 유형과 개수 등을 맞춰야 한다.  

목을 사용하면 시스템과 외부 애플리케이션 간의 통신 패턴을 확인할 때 좋다.
반대로 시스템 내 클래스 간의 통신을 검증하는데 사용하면 테스트가 구현 세부 사항과 결합되며 그에 따라 리팩터링 내성 지표가 미흡해진다.  

**시스템 내부 통신과 시스템 간 통신의 예**  
- 고객이 상점에서 제품을 구매하려고 한다.
- 매장 내 제품 수량이 충분하면
  - 재고가 상점에서 줄어든다. 
  - 고객에게 이메일로 영수증을 발송한다. 
  - 확인 내역을 반환한다.

목을 사용하는 타당한 예
<img src ="https://drek4537l1klr.cloudfront.net/khorikov2/Figures/05fig13_alt.jpg"><br/>
```
public void Successful_purchase()
{
    var mock = new Mock<IEmailGateway>();
    var sut = new CustomerController(mock.Object);
    
    bool isSuccess = sut.Purchase(customerId: 1, productId: 2, quantity: 5);
    Assert.True(isSuccess);
    mock.Verify(
        x => x.SendReceipt("customer@email.com", "Shampoo", 5),
    Times.Once); // 시스템이 구매에 대한 영수증을 보내는지 검증
}
```
SMTP 서비스에 대한 호출을 목으로 이용하는 게 타당하다.  
리팩터링 후에도 리팩토링 후에도 이런 통신 유형이 그대로 유지 되기 때문이기도하다.
isSuccess는 외부 클라이언트에서도 확인할 수 있고 검증도 필요하다.  
하지만 이 플래그는 목이 필요 없고, 간단한 값 비교만으로 충분하다.  

### 5.4 단위 테스트의 고전파와 런던파의 재고
| | 격리 주체 | 단위의 크기 | 테스트 대역 사용 대상 |  
|---|---|---|---|
|런던파|단위|단일 클래스|불변 의존성 외 모든 의존성|
|고전파|단위 테스트|단일 클래스 또는 클래스 세트|공유 의존성|

런던파는 불변 의존성을 제외한 모든 의존성에 목 사용을 권장하며  
시스템 내 통신과 시스템 간 통신을 구분하지 않는다.  
테스트는 애플리케이션과 외부 시스템 간의 통신을 확인하는 것터럼 클래스 간 통신도 확인한다.  

런던파를 따라 목을 무분별하게 사용하면 종종 구현 세부사항에 결합돼 테스트에 리팩터링 내성이 없게 된다.  

고전파는 테스트 간에 공유하는 의존성만 교체하므로 이 문제에 유리하지만 이상적이지는 않다.  
런던파만큼은 아니여도 고전파도 목사용을 지나티게 장려한다.  

**모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다.**  
- 공유 의존성 : 테스트 간에 공유하는 의존성
- 프로세스 외부 의존성 : 프로그램의 실행 프로세스 외에 다른 프로세스를 점유하는 의존성  
ex) 데이터 베이스, 메시지 버스, SMTP 서비스등
- 비공개 의존성 : 공유하지 않는 모든 의존성

공유 의존성이 프로세스 외부에 있는 것이 아니면 각 테스트 실행시 해당 의존성을 새 인스턴스로 써서 재사용을 피하기 쉽다.  
반면 공유 의존성이 프로세스 외부에 있으면 테스트가 더욱 복잡해진다.
각 테스트 실행 전마다 데이터베이스나 메시지 버스를 새로 준비한다면 테스트 스위트가 현저히 느려질 것이다.
이를 위해 공유 의존성을 테스트 대역인 목과 스텁으로 교체하는 것이 일반적인 접근 방법이다.  
그러나 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다.  

프로세스 외부 의존성이 어플리케이션을 통해서만 접근할 수 있다면 이런 의존성과의 통신은 시스템에서 식별할 수 있는 동작이 아니다.  
외부에서 관찰할 수 없는 프로세스 외부 의존성은 애플리케이션의 일부로 작용한다.  
애플리케이션이 외부 시스템에 대한 프록시 같은 역할을 하고 클라이언트가 직접 접근할 수 없으면 하위 호환성 요구 사항은 사라진다.  
외부 시스템과 애플리케이션을 같이 배포할 수 있으면 클라이언트에 영향을 미치지 않으며 이는 구현 세부사항이다.  
예를 들면 애플리케이션 데이터베이스가 있다.  
데이터 베이스는 클라이언트의 시야에서 완전히 숨어있기 때문에 전혀 다른 저장방식으로 대체될수 있고 그렇게 해도 아무도 모를 것이다.  
데이터베이스와 애플리케이션은 하나의 시스템으로 취급해야한다.  


