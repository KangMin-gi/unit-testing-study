# 좋은 단위 테스트의 4대 요소

- 가치 있는 테스트를 식별하는 방법

## 4대 요소 자세히 살펴보기
### 회귀 방지
- 회귀 (regression)
	- 코드를 수정한 후 기능이 의도한 대로 동작하지 않게 되는 것
- 테스트로 실행되는 코드가 많을수록 테스트에서 회귀를 발견하게 될 가능성이 높다. 
- 복잡한 비즈니스로직을 나타내는 코드에서 회귀가 발견될 가능성이 높음.
	- 반면 단순한 코드를 테스트하는 것은 가치가 거의 없음

### 리팩터링 내성
- 테스트를 빨간색(실패)로 바꾸지 않고 기존 어플리케이션 코드를 리팩터링할 수 있는지에 대한 척도
#### 거짓 양성(false positive)
- 실제로 기능이 의도한 대로 동작하지만 테스트는 실패를 나타내는 경우
- 테스트의 장점을 희석화
	- 테스트가 타당한 이유 없이 실패하면 코드 문제에 대응하는 능력과 의지 약화
	- 테스트 스위트에 대한 신뢰가 부족해짐 -> regression 피하고자 코드 변경 최소화 -> 리팩터링 줄어듦

#### 거짓 양성 원인
- 테스트와 테스트 대상 시스템(SUT) 의 구현 세부 사항이 많이 결합할수록 거짓 양성이 더 많이 생긴다.
	- 따라서 거짓 양성을 줄일 수 있는 방법은 구현 세부 사항 - 테스트 분리
	- 최종 사용자의 관점에서 SUT 를 검증해야 하고 최종 사용자에게 의미 있는 결과만 확인하자
- 테스트 - SUT 강결합된 코드 예시
![](attachments/스크린샷%202023-04-03%20오전%207.26.37.png)![](attachments/스크린샷%202023-04-03%20오전%207.26.43.png)

- 하위 렌더링 클래스의 유형과 순서를 검증하고 있음.
	- 그러나 하위 렌더링 클래스의 구성을 변경해도 HTML 문서는 동일하게 유지될 수 있음. 하지만 이때 위 테스트는 빨간불로 바뀌게 될 것. (거짓 양성)

- Q. 리팩터링 내성은 검증 구문과 연관된 내용인 건가?


#### 구현 세부 사항 대신 최종 결과를 목표로 하기
- 리팩터링 내성을 높이는 방법은 SUT 의 구현 세부 사항과 테스트 간 결합도를 낮추는 것
- 테스트 코드 작성 전 다음 질문을 먼저 확인하자
	- SUT 에서 얻는 최종 결과는 무엇인가?
- 코드 예시

![](attachments/스크린샷%202023-04-03%20오전%207.33.23.png)

- SUT 를 블랙박스로 취급하고 식별할 수 있는 동작에만 집중
	- SUT 의 최종 결과만 올바르게 출력하는 한 SUT 의 구현 변경 사항은 테스트에 영향을 미치지 않음
- (참고) 메서드에 매개변수가 추가될 때 나타나는 기술적인 거짓 양성은 피할 수 없음. 이런 거짓 양성은 컴파일러를 따라서 테스트를 수정하면 되기 때문에 간단한 문제

## 회귀방지 와 리팩터링 내성 간 관계

![](attachments/스크린샷%202023-04-03%20오전%207.38.31.png)
- 회귀방지는 Type2 error 를 최소화하는 데 도움이 됨.
- 리팩터링 내성은 Type1 error 를 피하는 데 도움이 됨.

![](attachments/스크린샷%202023-04-03%20오전%207.39.45.png)
- 테스트 정확도
	- 회귀를 잘 찾아낼수록, 거짓 양성이 적을수록 정확도가 높다.

![](attachments/스크린샷%202023-04-03%20오전%207.40.38.png)
- 프로젝트 초기에는 리팩토링 필요성이 낮아 거짓 양성이 있더라도 큰 문제가 아니지만 프로젝트가 진행될수록 리팩터링이 필요하게 되고, 리팩터링 내성도 점점 더 중요해짐.
- 중대형 프로젝트에서 작업하면 거짓 음성과 거짓 양성에 대해 똑같이 주의를 기울여야 한다.

## 빠른 피드백과 유지 보수성
### 빠른 피드백
- 테스트 속도가 빠를수록 더 많은 테스트를 수행할 수 있고 더 자주 실행할 수 있다.

### 유지 보수성
- 테스트가 얼마나 이해하기 쉬운가
	- 테스트는 코드 라인이 적을수록 더 읽기 쉬움
- 테스트가 얼마나 실행하기 쉬운가
	- e.g. 테스트가 프로세스 외부 종속성으로 작동하면 DB 서버를 재부팅하는 등의 비용 발생

## 이상적인 테스트를 찾아서
- 4대 특성 중 어떤 특성이라도 0이 되면 전체가 0이 된다.
- 각 특성에 대해 최소 필수값에 대해 높은 임계치를 설정하고 이 임계치를 충족하는 테스트만 스위트에 남기자

### 네 가지 특성을 모두 완벽하게 만족하는 테스트는 불가능
- 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적
	- 셋 중 하나를 희생해야 나머지 둘을 최대화 가능

#### 엔드 투 엔드 테스트 -> 빠른 피드백 포기
- 많은 코드를 테스트
	- 회귀 방지 뛰어남
- 최종 사용자 관점에서 기능 동작하는지 확인
	- 리팩토링 내성 뛰어남
- 테스트 실행 속도 느림

#### Trivial 테스트 -> 회귀 방지 포기
![](attachments/스크린샷%202023-04-03%20오전%207.49.57.png)
- 빠른 수행 속도
- 거짓 양성이 생길 가능성 낮음
- 코드에 실수할 여지가 적어서 테스트는 항상 통과하거나 검증이 무의미
	- 회귀 방지 어려움

#### 깨지기 쉬운 테스트 -> 리팩터링 내성 포기
![](attachments/스크린샷%202023-04-03%20오전%207.50.07.png)

- 테스트가 SUT 의 내부 구현 세부 사항에 결합됨.
	- 결과가 동일하도록 SQL script 를 변경하더라도 테스트가 깨짐.

### 이상적인 테스트 결론
- 우선 리팩터링 내성을 최대한 많이 갖는 것을 목표로 하자.
	- 리팩터링 내성은 갖거나 or 갖지 않거나 이진 선택.
	- 반면 회귀 방지와 빠른 피드백에 대한 지표는 조절 가능
- 테스트 유지 보수성은 다른 특성과 상관관계가 없으므로 테스트 유지 보수성 또한 높게 관리하자

## 테스트 자동화 개념
### 테스트 피라미드
- 테스트 스위트에서 테스트 유형 간의 비율을 일컫는 개념

![](attachments/스크린샷%202023-04-03%20오전%207.59.17.png)

- 너비
	- 테스트 스위트 내에서 해당 테스트가 얼마나 보편적인지
- 높이
	- 테스트가 최종 사용자의 동작을 얼마나 유사하게 흉내내는지
- 어느 계층도 리팩터링 내성을 포기해선 안 됨 (특히 단위테스트)
- 테스트 유형 간 비율은 팀, 프로젝트마다 다르겠지만 일반적으로는 위와 같은 피라미드 형태 유지 권장
- Q. 엔드 투 엔드 테스트, 통합 테스트 -> 자동화 가능한지?


### 블랙박스 테스트 vs 화이트박스 테스트
- 블랙박스 테스트
	- 시스템 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 테스트 방법
	- how 보다 what 에 집중
- 화이트박스 테스트
	- 어플리케이션의 내부 작업을 검증.
	- 테스트의 요구사항이나 명세가 아닌 소스코드에서 파생
	- 소스 코드를 분석하기 때문에 더 많은 오류를 발견할 수 있다는 장점
	- but, SUT 의 구현과 결합돼 있어 깨지기 쉬움. 즉, 리팩터링 내성 지표가 부족함.
- 화이트박스 테스트 대신 블랙박스 테스트를 기본으로 선택하자.
- 깨지기 쉬운 테스트는 재구성하거나 삭제하자.
- (참고) 테스트를 분석할 때는 화이트박스 방법 사용 가능. 
	- e.g. 코드 커버리지 도구를 사용해서 어떤 코드 분기를 실행하지 않았는지 확인하는 정도

---
- Q. 배포할 때 테스트 실행?
- alpha(개발) / beta(운영) / real(운영)
- `skip = true` -> PR 단계에서 테스트를 돌려본 덕분!
- 