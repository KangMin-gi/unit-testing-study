# 2장. 단위 테스트란 무엇인가?

---

<aside>
💡 2장에서 다루는 내용
ㅁ 단위 테스트란?
ㅁ 공유 의존성, 비공개 의존성, 휘발성 의존성 간의 차이점
ㅁ 단위 테스트의 두 분파 : 고전파와 런던파
ㅁ 단위 테스트, 통합 테스트, 엔드 투 엔드 테스트의 차이점

</aside>

# 2.1. ‘단위 테스트’의 정의

- 작은 코드 조각을 검증
- 빠르게 수행
    - 주관적 척도로 실행 시간이 충분하다면 테스트는 충분히 빠르다고 볼 수 있다.
- 격리된 방식으로 처리하는 자동화된 테스트
    - 고전파와 런던파를 구분하는 근원적 차이
    

## 2.1.1. 격리 문제에 대한 런던파의 접근

- 격리된 방식으로 검증한다는 것은 무엇을 의미?
    - 런던파
        - 테스트 대상 시스템을 협력자에게서 격리하는 것
        - 하나의 클래스가 다른 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체한다.
        - 동작을 외부 영향과 분리해서 테스트 대상 클래스에만 집중
        - 장점
            - 테스트 실패 시 코드베이스의 어떤 부분이 문제인지 확실히 알 수 있음.(문제는 테스트 대상 클래스에서 발생한 것이다.)
            - 객체 그래프를 분할할 수 있음.
                - 테스트 대역을 사용하면 클래스의 의존성을 대체할 수 있음.
                - 의존성의 의존성을 다룰 필요도 없음
            - 클래스에 해당하는 단위 테스트클래스를 생성하여 단위 테스트 스위트를 간단한 구조로 만들 수 있음.(1:1)

- **AAA 패턴(Arrange-Act-Assert, 준비-실행-검증)**
    - 준비
        - 의존성과 테스트 대상 시스템을 모두 준비하는 부분이다.
        - 테스트 대상 시스템(SUT, System Under Test)과 협력자를 준비한다.
            - 협력자가 필요한 이유
                1. 테스트 대상 메서드 컴파일 시, 인수로 필요시 되는 인스턴스가 있을 수 있다.
                2. 검증 단계에서 실행 결과 중 하나로 협력자의 속성 값이 바뀔 수 있다.
    - 실행
        - 검증하고자 하는 동작을 수행
    - 검증
        - 동작이 예상 결과로 이어지는지 확인

- 준비 단계에서 실제 인스턴스를 생성하지 많고 `Mock<T>` 를 사용해 대체
- 어떻게 응답하는지 Mock에 직접 정의
    - 예시
        - `storeMock.SetUp(…).Returns(…);`
        - 실제 Store 객체 사용하지 않고 IStore 인터페이스로 Mock생성 → 구체 클래스 타입으로 정의할 경우 **안티패턴**
- Mock 은 무엇인가?
    - 테스트 대역의 부분집합
    - 테스트 대역과는 단어의 뉘앙스 차이가 있음.(테스트 대역은 모든 가짜 의존성을 설명하는 포괄적 용어, 목은 의존성 중 한 종류)

## 2.1.2. 격리 문제에 대한 고전파의 접근

- 코드를 꼭 격리하는 방식으로 테스트 해야하는 것은 아니다.
- 대신 단위 테스트는 서로 격리해서 실행해야 한다.
    - 어떤 순서로든 가장 적합한 방식으로 실행 가능
    - 서로 결과에 영향이 없다.
    - 각 클래스가 격리되어 있다면 여러 클래스가 모두 메모리에 상주하고 공유 상태로 바뀌지 않는 한 한번에 여러 클래스를 테스트해도 괜찮다는 의미
    - **공유 상태 예시**
        - 데이터베이스, 파일 시스템 등 (프로세스 외부 의존성)
- 용어 설명
    - 공유 의존성(shared dependency)
        - 테스트 간 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성
        - 전형적 예시 중 정적 가변 필드와 데이터베이스가 있다.
        - 정적 가변 필드의 변경 사항은 동일한 프로세스 내에서 실행되는 모든 단위 테스트에서 볼 수 있다.
        - 공유 의존성은 테스트 대상 클래스(단위)간이 아니라 단위 테스트 간에 공유한다.
    - 비공개 의존성(private dependency)
        - 공유하지 않는 의존성
    - 프로세스 외부 의존성(out-of-process dependency)
        - 애플리케이션 실행 프로세스 외부에서 실행 되는 의존성
        - 메모리에 없는 데이터에 대한 프록시이다.
        - 프로세스 외부 의존성은 대부분 공유 의존성에 포함된다 하지만 모두 그런 것은 아님.
            - 예시 :  도커 컨테이너로 데이터베이스 시작 시 프로세스 외부면서 공유하지 않는 상태가 된다.
    - 휘발성 의존성(volatile dependency)
        
        
- 공유 의존성을 대체하는 이유
    - 생성자 등을 통해 다른 의존성이 SUT 에 주입되면 각 테스트에서 새 인스턴스를 만들 수 있음.
        - 테스트 스위트 전체에서 단일 인스턴스를 유지할 필요가 없다.
        - 하지만, 새 파일 시스템이나 데이터베이스를 만들 수는 없기 때문에 `테스트간 공유` or `테스트 대역으로 대체`
    - 테스트 실행 속도 향상
        - 공유 의존성은 거의 항상 실행 프로세스 외부에 있다.
        - 비공개 의존성은 경계를 넘지 않는다.
        - 비공개 의존성에 대한 호출보다 공유 의존성이 더 오래 걸림.
            
            → 공유 의존성을 가진 테스트는 단위 테스트 영역에서 **통합 테스트 영역으로 넘어간다.**
            
        - 공유 의존성이 없는 한 여러 클래스 묶어서 테스트할 수도 있긴 함.

# 2.2 단위 테스트의 런던파와 고전파

- 런던파와 고전파의 의견 차이

|  | 격리 주체 | 단위의 크기 | 테스트 대역 사용 대상 |
| --- | --- | --- | --- |
| 런던파 | 단위 | 단일 클래스 | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성 |
|  |  |  |  |

## 2.2.1. 고전파와 런던파가 의존성을 다루는 방법

- 런던파는 테스트에서 일부 의존성을 그대로 사용하도록 한다.
    - `불변 객체`는 교체하지 않아도 된다.
    - 불변 객체
        - **값 객체 또는 값**이라고 한다.
        - 각각의 정체성이 없다. 즉, 내용에 의해서만 식별된다.
        - 예시) 열거형 enum `Product`
- 협력자 vs 의존성
    - 협력자는 공유하거나 변경 가능한 의존성
    - Product 는 의존성이지만 협력자는 아니다. 값 또는 값 객체로 분류
    - 일반적 클래스는 두 가지 유형의 의존성으로 동작한다. → `협력자 또는 값`
- 공유 의존성과 프로세스 외부 의존성 간의 관계
    - 공유 의존성 → `싱글턴`
    - 공유 의존성 + 프로세스 외부 의존성 → `데이터베이스`
    - 프로세스 외부 의존성 → `읽기 전용 API 서비스`

# 2.3 고전파와 런던파의 비교

- 런던파 접근 방식의 장점
    - 입자성(granularity)이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인
    - 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다. 모든 협력자는 테스트 대역으로 대체되기에 걱정할 필요 없다.
    - 테스트 실패 시 어떤 기능이 실패했는지 확실히 알 수 있다. 테스트 내 다른 의존성은 제거했기 때문에 테스트 대상 클래스 또는 값 객체 문제 둘 중 하나로 볼 수 있음.

## 2.3.1. 한 번에 한 클래스만 테스트하기

- 런던파는 클래스를 단위로 간주한다.
- 단일 동작 단위를 검증하는 한 좋은 테스트다.
- 그러나, 좋은 코드 입자성을 목표로 하는 것은 도움이 되지 않는다.

## 2.3.2. 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

- 직접적인 의존성을 대체해 테스트 대역을 쓰면 단위 테스트에서 준비해야할 작업량을 크게 줄일 수 있다.
    - 고전파 스타일로 할 경우 전체 객체 그래프를 다시 생성하여 작업이 많다..
    - 그러나 그 이전에, 클래스 그래프가 커진 상황이라면 코드 설계가 잘못 되었을 확률이 높다.

## 2.3.3. 버그 위치 정확히 찾아내기

- 런던 스타일은 보통 SUT 에 버그가 포함된 테스트만 실패한다.
- 고전 스타일은 클라이언트 테스트도 실패할 수 있다. 디버깅에 시간도 오래 걸림.
    
    → 테스트를 정기적으로 실행하여 버그를 사전에 방지한다.
    
    → 긍정적으로 보자면 문제의 버그 발생의 코드 조각에 전체가 의존한다는 것을 알게 됨.
    

## 2.3.4. 고전파와 런던파 사이의 다른 차이점

- `TDD를 통한 시스템 설계 방식`과 `과도한 명세 문제`
- 테스트 주도 개발(TDD, Test Driven Development)이란?
    - 테스트에 의존해 프로젝트 개발을 추진하는 소프트웨어 개발 프로세스
    - 프로세스는 3단계로 구성, 각 테스트 케이스마다 반복해서 적용
        1. 추가해야 할 기능과 어떻게 동작하는지 나타내는 실패 케이스 작성
        2. 테스트가 통과할 만큼 충분히 코드 작성(깨끗한 코드를 위해 노력하지는 않아도 된다.)
        3. 코드 리팩토링(이 단계에서 코드를 다듬는다.)
    - 런던 스타일은 하향식 TDD 다.
        - 전체 시스템에 대한 기대치 설정하는 상위 레벨 테스트부터 시작
    - 고전 스타일은 상향식 TDD 다.
    - 도메인 모델부터 시작해서 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 쌓는다.
- 이들 간 가장 중요한 차이점은 **과도한 명세 문제**이다.
    - 테스트가 SUT의 구현 세부 사항에 결합되는 것
    - 런던 스타일이 더 자주 결합되는 편(목을 전반적으로 아무데나 쓰는 것에 대한 이의 제기가 있음)
    

# 2.4. 두 분파의 통합 테스트

- 두 분파는 통합 테스트에 대한 정의에도 차이가 있다.
- 런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다.
- 단위 테스트의 정의
    1. 작은 코드 조각을 검증
    2. 빠르게 수행
    3. 격리된 방식으로 처리
- 고전파 관점에서 다시 정의한 단위 테스트
    1. 단일 동작 단위를 검증
    2. 빠르게 수행
    3. 다른 테스트와 별도로 처리
- 통합 테스트는 3번을 충족하지 않는 테스트이다.
- 프로세스 외부 의존성에 접근하면 테스트가 느려진다.
- 둘 이상의 동작 단위를 검증할 때 통합 테스트를 한다.
- 다른 팀이 개발한 모듈이 둘 이상 있을 때 통합 테스트로 어떻게 작동하는지 검증할 수도 있다.
    
    **→ 통합 테스트는 시스템 전체를 검증해서 소프트웨어 품질에 중요한 기여를 한다.**
    

## 2.4.1. 통합 테스트의 일부인 엔드 투 엔드 테스트

- 엔드 투 엔드 테스트
    - 통합 테스트의 일부이다.
    - 코드가 프로세스 외부 종속성과 함께 어떻게 작동하는지 검증
    - 통합 테스트 보다 의존성을 더 많이 포함한다.
    - UI 테스트, GUI 테스트, 기능 테스트 모두 같은 용어이다.
    - 예시
        - 데이터베이스, 파일 시스템, 결제 게이트웨이 3가지 프로세스 중 데이터베이스와 파일 시스템만 통합 테스트에 포함하고, 결제 게이트웨이는 테스트 대역으로 대체한다.
    - 유지 보수 비용이 가장 많이 드는 테스트로 모든 단위, 통합 테스트 통과 후 빌드 프로세스 후반에 실행하는 것이 좋다.(빌드 서버에서만 실행할 수도 있다.)
    - 통합 테스트와 엔드 투 엔드 테스트 사이에 뚜렷한 경계가 없다.