# 단위 테스트 구조

## 단위 테스트를 구성하는 방법
### AAA 패턴 사용
- Arrange (준비)
	- SUT(테스트 대상 시스템) 과 그것의 의존성을 원하는 상태로 만든다.
- Act (실행)
	- SUT 에서 메서드를 호출하고 준비된 의존성을 전달하고, 출력 값을 캡처한다.
- Assert (검증)
	- 결과(반환 값, SUT 와 협력자의 최종 상태, 협력자에 호출한 메서드 등)를 검증한다. 
- 테스트를 작성할 때는 `준비` 부터 시작하는 것이 자연스럽지만 TDD 를 진행할 때는 `검증` 부터 작성하는 것도 허용 

![](attachments/스크린샷%202023-03-27%20오전%208.10.38.png)

### 여러 개의 준비, 실행, 검증 구절 피하기
- 여러 개의 준비, 실행, 검증 구절은 테스트가 너무 많은 것을 한 번에 검증한다는 의미.
	- 하나의 테스트를 여러 개의 테스트로 나눠서 해결
- 단, 통합 테스트에서는 실행 구절을 여러 개 두는 것이 괜찮을 때도 있음.

![](attachments/스크린샷%202023-03-27%20오전%208.13.10.png)

### 테스트 내 if 문 피하기
- if 문이 있는 단위 테스트는 안티 패턴.
- 테스트가 너무 많은 것을 검증한다는 걸 암시.
	- 여러 테스트로 나누는 걸 권장
- 통합테스트에서도 if 문 허용 X

### 각 구절은 얼마나 커야 하는가?
#### 준비 구절이 가장 큰 경우
- 같은 테스트 클래스 내 비공개 메서드 혹은 별도의 팩토리 클래스로 도출하자
- 준비 구절에서 코드 재사용 시 도움되는 패턴
	- Object Mother
	- Test Data Builder

#### 실행 구절이 한 줄 이상인 경우를 경계하라
##### 잘못된 예시
![](attachments/스크린샷%202023-03-27%20오전%208.17.35.png)

- 단일 작업을 수행하는 데 두 개의 메서드 호출이 필요
	- 캡슐화 위반
		- 클라이언트 코드에서 두번째 메서드를 호출하지 않으면 데이터에 모순이 생길 수 있음

#### 검증 구절에는 검증문이 얼마나 있어야 하는가
- 하나의 테스트에 검증문이 여러 개 있을 수 있음.
- but, 검증 구절이 너무 커지는 것은 경계
	- e.g. 반환된 객체의 모든 속성을 검증하기 보다 적절한 `equals` 를 정의하는 것이 좋음

#### 테스트 대상 시스템 구별하기
- SUT 와 의존성을 구분하는 것이 중요.
- 테스트 내 SUT 이름을 `sut` 로 짓는 것을 권장
	- Q. 실무에서도 가능할까...?
![](attachments/스크린샷%202023-03-27%20오전%208.22.06.png)


#### 준비, 실행, 검증 주석 제거하기
- AAA 패턴을 따르고, 준비 빛 검증 구절에 빈 줄을 넣지 않아도 된다면 구절 주석들을 제거하고 빈 줄로 각 구절을 구분하라
- 그렇지 않으면 구절 주석을 유지하라

![](attachments/스크린샷%202023-03-27%20오전%208.23.31.png)

## 테스트 간 테스트 픽스처 재사용
- 준비 구절에서 코드를 재사용하자

#### 테스트 픽스처
- a fixed state of a set of objects used as a baseline for running tests
- SUT 로 전달되는 인수
- 각각의 테스트가 실행되기 전에 known, fixed 된 상태로 남아 있어야 하기 때문에 `fixture` 라고 불림

### 테스트 픽스처 재사용 올바르지 않은 예시
- 테스트 클래스 생성자에서 픽스처를 초기화

![](attachments/스크린샷%202023-03-27%20오전%208.36.10.png)
- 문제점
	- 테스트 간 결합도가 높아짐
	- 테스트 가독성이 떨어짐
		- 테스트 메서드만 보았을 때 테스트 메서드가 무엇을 하는지 이해하기 어려움.
		- 준비 로직이 별로 없더라도(픽스처의 인스턴스화만 있더라도) 테스트 메서드로 옮기는 것이 좋음.

#### 테스트 간의 높은 결합도는 안티 패턴이다
- e.g. 위 생성자에서 샴푸 개수를 10 -> 15 개로 바꾸면 의도치 않은 테스트가 실패할 수 있음.
- 따라서 테스트를 수정해도 다른 테스트에는 영향이 없는 것이 좋음
- 이를 위해 테스트 클래스에 공유 상태를 두지 않는 것을 권장

### 더 나은 테스트 픽스처 재사용법
- 테스트 클래스에 private factory method 를 두는 것

![](attachments/스크린샷%202023-03-27%20오전%208.44.10.png)
![](attachments/스크린샷%202023-03-27%20오전%208.44.30.png)
- private method 를 충분히 generic 하게 만든다면 테스트가 서로 결합되지 않음.
- 예외
	- fixture 가 거의 모든 테스트에서 사용된다면 테스트 생성자에서 fixture 를 인스턴스화 해도 괜찮음.
	- 단, 이 경우엔 base class 를 둬서 base class 의 생성자에서 fixture 를 인스턴스화하는 것이 바람직.

![](attachments/스크린샷%202023-03-27%20오전%208.48.53.png)

## 단위 테스트 명명법

- `[테스트 대상 메서드]_[시나리오]_[예상 결과]`
	- 흔하게 사용되지만 권장하지 않는 방식
	- e.g. 
		- `public void Sum_of_two_numbers()` (O)
		- `public void Sum_TwoNumbers_ReturnsSum()` (X)

#### 단위 테스트 naming guidelines
- 엄격한 명명 정책을 두지 말자.
- 문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자.
- (참고) Test 클래스 이름을 지정할 때 `[클래스명]Tests` 패턴을 사용하지만, 이는 이 테스트가 해당 클래스만 검증하는 것으로 제한하는 것은 아님.
	- 여기서 '클래스명' 은 단지 동작 단위를 검증할 수 있는 진입점에 해당

#### guideline 을 따르는 예제
![](attachments/스크린샷%202023-03-27%20오전%208.54.40.png)![](attachments/스크린샷%202023-03-27%20오전%208.54.50.png)

- 테스트 메서드 이름 개선
	-  `public void Delivery_with_invalid_date_should_be_considered_invalid()`
		- SUT 의 메서드 이름 제외
	- `public void Delivery_with_past_date_should_be_considered_invalid()`
		- 'invalid' 의미 구체화
	-  `public void Delivery_with_past_date_should_be_invalid()`
		- 불필요한 'considered' 제외
	-  `public void Delivery_with_past_date_is_invalid()`
		- 'should be' 는 안티 패턴에 해당. 테스트는 동작 단위에 대한 단순하고 원자적인 사실
	-  `public void Delivery_with_a_past_date_is_invalid()`
		- 영문법 준수위해 관사 추가

#### 테스트 메서드 이름에 SUT 의 메서드 이름을 넣지 말라
- SUT 는 단지 진입점, 동작을 호출하는 수단일 뿐.
- SUT 메서드 이름을 넣으면 코드 구현과 테스트 간 결합도가 높아짐
	- 테스트 스위트의 유지 보수성 저해

## 매개 변수화된 테스트로 리팩터링하기
- 매개변수화된 테스트를 사용하면 유사한 사실을 단일한 테스트 메서드로 묶을 수 있음.
- [Junit](https://www.baeldung.com/parameterized-tests-junit-5)
- 예시
	- public void Delivery_for_today_is_invalid()
	- public void Delivery_for_tomorrow_is_invalid()
	- public void The_soonest_delivery_date_is_two_days_from_now()
	- public void Delivery_with_a_past_date_is_invalid()
- 위 네가지 테스트를 하나의 테스트 메서드로 합쳐보자.

![](attachments/스크린샷%202023-03-27%20오전%209.02.55.png)

- 만약 파라미터가 추가된 후 가독성이 떨어진다면 긍정 테스트를 별도의 메서드로 빼낼 수 있다.

![](attachments/스크린샷%202023-03-27%20오전%209.04.03.png)
- 만약 동작이 너무 복잡하다면 매개변수화된 테스트를 사용하지 않는 것을 권장

## 검증문 라이브러리를 사용한 테스트 가독성 향상
- 검증문 라이브러리를 사용해 테스트 가독성을 높일 수 있다.
	- 단어 순서를 바꿔서 검증문을 읽기 쉽게 만들 수 있음.
	- e.g. Junit Assertions.assertj
- 유일한 단점은 프로젝트에 의존성을 추가해야 한다는 점.

![](attachments/스크린샷%202023-03-27%20오전%209.05.50.png)

