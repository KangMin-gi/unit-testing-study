# 목과 테스트 취약성

- 목이 취약한 테스트(리팩터링 내성이 부족한 테스트)를 초래하는 경우를 살펴보자

## 목과 스텁 구분
![](attachments/스크린샷%202023-04-09%20오후%2011.37.50.png)

- 테스트 대역은 크게 Mock, Stub 두 유형으로 분류 가능
- Mock
	- 외부로 나가는 상호 작용을 모방하고 *검사*하는 데 도움이 됨
	- sut 가 상태를 변경하기 위해 의존성을 호출하는 경우
	- e.g. 이메일 발송
- Stub
	- 내부로 들어오는 상호 작용을 모방하는 데 도움이 됨
	- sut 가 입력 데이터를 얻기 위해 의존성을 호출하는 경우
	- e.g. DB 조회
- (참고) 도구로서의 Mock
	- 도구로서의 Mock == Mock class
		- Mock class 를 사용해 mock 과 stub 을 생성한다.
	- 테스트 대역으로서의 Mock == mock instance

### 스텁으로 상호 작용을 검증하지 말라
- 스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 안티패턴
- 안티패턴 예시

![](attachments/스크린샷%202023-04-09%20오후%2011.44.06.png)
- `GetNumberOfUsers()` 를 호출하는 것은 결과가 아니라 내부 구현 세부 사항.
	- 따라서 이를 검증하는 것은 테스트 취약성으로 이어질 수 있음
- 최종 결과가 아닌 사항을 검증하는 관행을 '과잉 명세'(overspecification) 이라고 부름

#### Mock 이면서 Stub 인 사례

![](attachments/스크린샷%202023-04-09%20오후%2011.45.52.png)
- `hasEnoughInventory()` : stub 에 해당 -> 검증 (X)
- `removeInventory()` : mock 에 해당 -> 검증 (O)

### 명령, 조회 - 목, 스텁 간 관계
- 명령 조회 분리 원칙(Command Query Separation)
	- 모든 메서드는 명령이거나 조회여야 하며 둘을 혼용해선 안 됨
- 명령
	- 사이드이펙트 발생
	- 어떤 값도 반환하지 않음(void)
	- 명령을 대체할 때는 Mock 을 사용
- 조회
	- 사이드이펙트 없음
	- 값 반환
	- 조회를 대체할 때는 Stub 을 사용


## 식별할 수 있는 동작과 구현 세부 사항
- 거짓 양성 발생 원인
	- 테스트 - 구현 세부 사항 강결합
	- 문제 해결
		- 최종 결과(식별할 수 있는 동작)를 검증하고 구현 세부 사항과 테스트를 가능한 떨어뜨려 놓는 것

### 식별할 수 있는 동작 != public api
- production code 분류
	- public api - private api
	- observable behavior - implementation details
- 식별할 수 있는 동작 조건 (둘 중 하나를 만족해야 함)
	- 클라이언트가 목표를 달성하는데 도움이 되는 operation 노출
	- 클라이언트가 목표를 달성하는데 도움이 되는 state 노출
- 이상적으로 설계된 API
	- 식별할 수 있는 동작 == 공개 API
	- 구현 세부 사항 == 비공개 API

#### 구현 세부 사항 유출 예시 : operation
![](attachments/스크린샷%202023-04-10%20오전%2012.01.42.png)
![](attachments/스크린샷%202023-04-10%20오전%2012.01.51.png)

- 클라이언트의 목표 : user name 을 변경하는 것.
- 이 목표를 만족하는 데 도움이 되는 것은 Name 속성 뿐
- but, 목표 달성에 도움이 되지 않는 `NormalizeName()` 또한 public 으로 선언되어 있음
	- `NormalizeName()` 는 구현 세부사항에 해당됨
- 올바른 예시
	- 식별할 수 있는 동작(Name 속성) 만 공개
	- 구현 세부사항 (`NormalizeName()`) 은 비공개

![](attachments/스크린샷%202023-04-10%20오전%2012.04.26.png)

- 클래스가 구현 세부 사항을 유출하는지 판단하는 데 도움이 되는 유용한 규칙
	- 단일 목표를 달성하고자 클래스에서 호출해야 하는 연산 개수가 1보다 큰지 확인

#### 잘 설계된 API 와 캡슐화
- 구현 세부 사항을 노출하면 불변성을 위반할 수 있다.
	- e.g. 위 예시에서 클라이언트는 불변성을 우회해서 이름을 먼저 정규화하지 않고 새로운 이름을 할당할 수 있었음
- 장기적으로 코드베이스를 유지할 때 가장 중요한 것은 캡슐화
	- 계속해서 증가하는 코드 복잡도에 대처할 수 있는 유일한 방법
	- 실수할 가능성을 최대한 없애라. 캡슐화를 올바르게 유지해 코드베이스에서 잘못할 수 있는 옵션조차 제공하지 말라
- `tell-don't-ask` 원칙 by Martin Fowler
	- 데이터를 연산 기능과 결합하기

#### 구현 세부 사항 유출 예시 : state
![](attachments/스크린샷%202023-04-10%20오전%208.10.39.png)![](attachments/스크린샷%202023-04-10%20오전%208.10.44.png)

- `SubRenderers` 속성이 Public 으로 설정되어 있음
	- 클라이언트의 목표는 HTML 을 렌더링하는 것이므로 위 속성은 클라이언트 목표 달성에 도움이 되지 않음. 즉, 식별할 수 있는 동작이 아님. 구현 세부사항 유출에 해당
- 개선사항
	- 식별할 수 있는 동작인 `Render()` 메서드만 public 으로 둔다.
	- 테스트 대상 또한 `Render()` 메서드로 바꾼다. 
- 좋은 단위 테스트 - 잘 설계된 API 사이에는 본질적인 관계가 있음
	- 모든 구현 세부 사항을 비공개로 하면 테스트가 식별할 수 있는 동작을 검증하는 것 외에는 다른 선택지가 없고 자동으로 리팩터링 내성도 좋아짐

## 목과 테스트 취약성 간의 관계
### 육각형 아키텍처 정의
![](attachments/스크린샷%202023-04-10%20오전%208.14.57.png)

- domain(business logic)
	- 어플리케이션의 필수 기능
- application services
	- 도메인 계층 위에 위치
	- 외부 환경과의 통신 조정
		- e.g. 데이터베이스 조회 후 해당 데이터로 도메인 클래스 인스턴스 구체화
		- 해당 인스턴스에 연산 호출
		- 결과를 다시 데이터베이스에 저장

### 육각형 아키텍처 세가지 지침
#### (1) 도메인 계층과 어플리케이션 서비스 계층 간 관심사 분리
- 도메인 계층
	- 비즈니스 로직에 대해서만 책임을 지고 다른 모든 책임에서는 제외
- 어플리케이션 서비스
	- 어떤 비즈니스 로직도 있으면 안 됨

#### (2) 어플리케이션 내부 통신
- 어플리케이션 서비스 계층 -> 도메인 계층 단방향 의존성 흐름
- 도메인 계층은 계층 내부 클래스끼리 서로 의존하고 어플리케이션 서비스 계층의 클래스에 의존하지 않음
- 어플리케이션 서비스 계층은 도메인 서비스 계층 의존 가능

#### (3) 어플리케이션 간의 통신
- 외부 어플리케이션은 어플리케이션 서비스 계층에 있는 common interface 를 통해 해당 어플리케이션에 연결됨. 즉, 도메인 계층에 직접 접근 불가


![](attachments/스크린샷%202023-04-10%20오전%208.23.42.png)

- 테스트는 항상 비즈니스 요구사항으로 거슬러 올라갈 수 있어야 함
	- 그렇지 않다면 테스트 - 구현 세부사항이 결합되어 있음을 암시
- 식별할 수 있는 동작은 바깥 계층에서 안쪽 계층으로 흐른다.
- 외부 클라이언트에게 중요한 목표는 개별 도메인 클래스에서 달성한 하위 목표로 변환된다. 
- 코드 조각이 식별할 수 있는 동작이 되려면 클라이언트가 목표를 달성하도록 도울 필요가 있다.
- 앞장에서 줄곧 이야기하던 핵심 비즈니스 로직만 테스트 하라는 것과도 연관되겠다.


![](attachments/스크린샷%202023-04-10%20오전%208.27.32.png)

- 위 예시에서 사용자 이름을 정규화하는 것은 외부클라이언트의 목표가 아님 (알 바 아님)
	- 바꿔 말하면 `NormalizeName()` 은 클라이언트의 요구 사항으로 추적될 수 없음. 즉, 구현 세부 사항이므로 Private 으로 두는 것이 적절

### 시스템 내부 통신과 시스템 간 통신
![](attachments/스크린샷%202023-04-10%20오전%208.30.23.png)

- 시스템 내부 통신
	- 어플리케이션 내 클래스 간의 통신
	- 구현 세부사항
	- Mocking 하면 테스트 - 구현 세부사항 결합 -> 리팩터링 내성 지표 미흡
- 시스템 간 통신
	- 어플리케이션이 다른 어플리케이션과 통신하는 것
	- 식별할 수 있는 동작
	- Mocking 하면 시스템 - 외부 어플리케이션 간 통신 패턴 확인 가능 (good)

![](attachments/스크린샷%202023-04-10%20오전%208.35.31.png)

### 시스템 내부 통신과 시스템 간 통신 예시

![](attachments/스크린샷%202023-04-10%20오전%208.42.30.png)![](attachments/스크린샷%202023-04-10%20오전%208.42.36.png)

- application service
	- CustomerController
- domain
	- Customer
	- Product
	- Store
- 외부 application
	- EmailGateway

![](attachments/스크린샷%202023-04-10%20오전%208.45.18.png)

- 시스템 간 통신
	- `CustomerController` - SMTP service 통신
	- `CustomerController` - Third-party system 통신
- 시스템 내부 통신
	- `Customer` - `Store` 클래스 간 통신

![](attachments/스크린샷%202023-04-10%20오전%208.46.39.png)

- 시스템 간 통신을 Mocking 하는 것은 테스트 취약성을 야기하지 않는다.

![](attachments/스크린샷%202023-04-10%20오전%208.47.33.png)

- 시스템 내부 통신을 Mocking 했으므로 테스트 취약성이 생긴다.
- `removeInventory()` 는 클라이언트의 목표(물건 구매) 에 도움이 되는 연산이 아니다. 즉, 식별할 수 있는 동작이 아니고 구현 세부사항에 해당
- Q. DB 를 업데이트하는 것도 검증 대상이 아닌 것인지?

## 단위테스트의 고전파와 런던파 revisited

![](attachments/스크린샷%202023-04-10%20오전%208.59.44.png)

- 런던파
	- 불변의존성을 제외한 모든 의존성에 목 사용을 권장
	- 시스템 내 통신 - 시스템 간 통신 구분 X
	- 클래스 간 통신도 검증
- 고전파
	- 테스트 간에 공유하는 의존성만 교체
	- 시스템 간 통신 처리할 때 이상적이진 않음

### 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다
- 프로세스 외부 의존성이 어플리케이션을 통해서만 접근할 수 있다면 이런 의존성과의 통신은 시스템에서 식별할 수 있는 동작이 아님.
	- 즉 외부에서 관찰할 수 없는 프로세스 외부 의존성은 어플리케이션의 일부로 작용
- 하위 호환성 요구 사항이 사라진다면 외부 의존성과의 통신 또한 구현 세부 사항이 됨

![](attachments/스크린샷%202023-04-10%20오전%209.03.56.png)

- 대표적인 예시가 어플리케이션에서만 사용되는 데이터베이스
- 이 데이터베이스는 클라이언트 시야에서 완전히 숨어있기 때문에 전혀 다른 저장 방식으로 대체할 수 있고 그렇게 해도 아무도 모른다.
- 이런 외부 의존성에 목을 사용하면 깨지기 쉬운 테스트로 이어진다.
	- Q. 데이터베이스를 mocking 하지 말란 이야기..? 아니면 검증만 하지 말라는 이야긴가? -> chpt 6,7 장에서 설명
- 데이터베이스와 어플리케이션은 하나의 시스템으로 취급해야 한다.

### 목을 사용한 동작 검증
- 각 개별 클래스가 이웃 클래스와 소통하는 방식은 식별할 수 있는 동작과 관계가 없다. (구현 세부사항에 해당)
- 중요한 것은 클라이언트 목표로 거슬러 올라갈 수 있는 동작
- 목은 어플리케이션의 경계를 넘나드는 상호작용을 검증할 때와 이러한 상호 작용의 사이드 이펙트가 외부 환경에서 보일 때만 동작과 관련 있다.