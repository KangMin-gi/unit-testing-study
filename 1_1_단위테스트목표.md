# 단위테스트 목표


1. 요약
   - 가장 중요한건 고품질 테스트에 집중하는것
   - 가치가 없는 테스트 코드로 이뤄질 경우, 언젠간 침체기에 빠져들 수 있다. 
1. 단위 테스트
1. 성공적 테스트 스위트
    - 개발 주기에 통합
    - 가장 중요한 부분을 대상
    - 최소 유지비로 최대 보상
1. 커버리지에 대한 고찰
    - 테스트 커버리지
        - 단순 코드 검증 라인수만 계산 하기 떄문에, 일정 미만 이라면 당연히 안좋지만 일정 이상이라고 좋은 테스트를 할 수 있다고 말할수는 없다.
    - 분기 커버리지
        - 테스트 커버리지보다 좋은 인사이트를 제공하지만, 몇몇 문제점이 있다. (etc. 외부 라이브러리에)
---

### 내생각 (여기는 좀더 정리)
~~~ 
 1. 나는 테스트 커버리지 (Line Base) 만을 생각 했었다.
 1. 좋은 테스트를 만들고 싶지만, 방법을 모르는 경우도 많았다.
    - 지금도 잘 모르는 경우가 많음
    - 특히 Controller Service Repository 와 같은 상황에서는 정말 정말 모킹할게 많아서 어렵더라
 1. 레거시 소스코드에서, 테스트 케이스 없이 추가된 것들을 리팩토링 하는 일정은 주어지지 않는다.
    - 회사의 생산성 입장에서는, 그럴 수 있다고 생각한다.
    - 정말 service에 20~30개의 빈이 들어와 있으면 어지럽
~~~

---

### Unknown

1. TestSuite
 - 테스트 케이스는 "무엇을 테스트할 것인가?"라는 질문에 대한 답을 제공합니다. 테스트 케이스를 개발하여 시스템이 올바로 작동하고 높은 품질 수준에서 빌드되도록 유효성을 검증해야 하는 사항을 정의할 수 있습니다. 테스트 스위트는 테스트 실행 목적으로 그룹화된 테스트 케이스의 콜렉션입니다.
 - 출처 [IBM 테스트 케이스 및 테스트 스위트 개요](https://www.ibm.com/docs/ko/elm/6.0.5?topic=testing-test-case-test-suite-overview)
---

### example Code

```java
public class TestOuter {
    
    @Test
    public void testCoverage() {
        // 이 코드는 100% 의 분기, 테스트 커버리지를 보이지만 당연히 오류가 나는 코드다.
        // 많이 사용하는(나도) 테스트 커버리지는 이같은 경우를 당연히 볼 수 없다.
        targetMethod("dsa"); 
    }
    
    private Integer targetMethod(String numberString) {
        return Integer.parseInt(numberString);
    }
}
```

```java
public class Outer2 {

    Integer cache;

    public Integer targetMethodWithCache(String numberString) {
        int i = Integer.parseInt(numberString);
        this.cache = i;
        return i;
    }
    
    @Test
    public void test() {
        // 이 함수의 테스트 에서는, Return 값만 테스트 하고 다른 값에대한 검증은 전혀 없다.
        // 테스트 커버리지는 100%가 되겠지만, 의미가 퇴색
        int num = targetMethodWithCache("1");
        assertThat(1, num);
        int num2 = targetMethodWithCache("2");
        assertThat(2, num2);
    }
}
```