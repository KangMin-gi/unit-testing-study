# 4장 좋은 단위 테스트의 4대 요소
* 좋은 단위 테스트 스위트의 특성
    * 개발 주기에 통합되어 있다.
    * 코드베이스에서 가장 중요한 부분을 테스트 한다.
    * 최소한의 유지비로 최대 가치를 끌어낸다.
        * ```가치 있는 테스트 식별``` 과 ```가치 있는 테스트 작성```을 할 수 있어야 한다.
## 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기
* 회귀 방지
* 리팩터링 내성
* 빠른 피드백
* 유지 보수성
### 4.1.1 첫 번째 요소: 회귀 방지
* 회귀 == 소프트웨어 버그
* 코드베이스가 커질수록 잠재적인 버그에 더 많이 노출되므로 회귀에 대해 효과적인 보호를 하는 것이 중요하다.
* 회귀 방지 지표에 대한 테스트 평가 기준
    * 테스트 중에 실행되는 코드의 양: 일반적으로 실행되는 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다.
    * 코드 복잡도: 비즈니스 로직은 대체로 복잡하고 중요하다.
    * 코드의 도메인 유의성: 비즈니스 로직을 나타내는 코드에서 발생한 버그가 가장 큰 피해를 입힌다.
* 라이브러리, 프레임워크, 프로젝트 외부 시스템 등 직접 작성하지 않은 코드에 대해서도 테스트 범주에 포함시켜 검증을 해야 한다.
* [팁]: 회귀 방지 지표를 극대화하려면 테스트가 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.
### 4.1.2 두 번째 요소: 리팩터링 내성
* 기본 애플리케이션 코드를 리팩터링 해도 테스트가 실패하지 않는지에 대한 척도
* 리팩터링은 식별할 수 있는 동작을 수정하지 않고도 기존 코드를 변경하는 것을 의미한다. 그 의도는 코드의 비기능적 특징을 개선하는 것으로, 가독성을 높이고 복잡도를 낮추는 것이다.
* 리팩터링 후 기능은 정상 동작하지만 테스트가 실패하는 경우를 거짓 양성<sup>false positive</sup> 이라고 한다.
* 테스트의 거짓 양성 비중이 적을수록 리팩터링 내성 지표의 점수가 높다.
* 리팩터링 내성의 장점
    * 기존 기능이 고장 났을 때 테스트가 조기 경고를 제공한다. 이러한 조기 경고 덕분에 결함이 있는 코드가 운영 환경에 배포되기 훨씬 전에 문제를 해결할 수 있다.
    * 코드 변경이 회귀로 이어지지 않을 것이라고 확신하게 된다.
* 거짓 양성의 단점
    * 테스트가 타당한 이유 없이 실패하면, 코드 문제에 대응하는 능력과 의지가 희석된다. 시간이 흐르면서 그러한 실패에 익숙해지고 그만큼 신경을 많이 쓰지 않게 되어 타당한 실패도 무시하게 될 수 있다.
    * 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 떨어진다. 신뢰가 부족해지면 회귀를 피하려고 코드 변경을 최소한으로 하기 때문에 리팩터링도 줄어든다.
* 거짓 양성이 많으면 회귀 없이 주기적으로 리팩터링하고 새로운 기능을 추가하기가 어려워지기 때문에 프로젝트의 지속 가능성을 떨어뜨린다.
### 4.1.3 무엇이 거짓 양성의 원인인가?
* 테스트와 SUT 의 구현 세부 사항이 많이 결합할수록 허위 경보가 더 많이 생긴다.
* 해당 구현 세부 사항에서 테스트를 분리하자! 즉, 최종 사용자 관점에서 SUT를 검증해야 하고 최종 사용자에게 의미 있는 결과만 확인해야 한다.
```kotlin
class MessageRenderer() : IRenderer {

    val subRenderers = listOf(
        HeaderRenderer(),
        BodyRenderer(),
        FooterRenderer(),
    )

    override fun render(message: Message): String {
        return subRenderers.joinToString("") { it.render(message) }
    }
    
}
```
애플리케이션 코드
```kotlin
@Test
  fun `MessageRenderer uses correct sub renderers`() {
  
    val sut = MessageRenderer()
  
    val renderers = sut.subRenderers
  
    assertEquals(3, renderers.size)
    assertTrue { renderers[0] is HeaderRenderer }
    assertTrue { renderers[1] is BodyRenderer }
    assertTrue { renderers[2] is FooterRenderer }
  }
```
테스트 코드
* 다음의 애플리케이션 코드에서 MessageRenderer 의 subRenderers 를 재배열하거나 그 중 하나를 다른 것으로 교체한다면 테스트가 실패한다. 이는 구현 세부 사항과 결합했기 때문이다.
* SUT가 생성한 결과가 아닌 SUT의 구현 세부 사항과 일치하는 경우 테스트가 깨지기 쉽다. SUT의 구현을 리팩터링 하면 테스트가 실패한다.
* 따라서 SUT의 구현 세부 사항과 결합된 테스트는 리팩터링 내성이 없다.
* 구현 세부 사항과 결합되었을 때의 단점
    * 버그 발생 시 조기 경고를 제공하지 않는다. 대부분 잘못된 것이므로 이러한 경고는 무시하게 된다.
    * 리팩터링에 대한 능력과 의지를 방해한다.
### 4.1.4 구현 세부 사항 대신 최종 결과를 목표로 하기
* 최종 사용자에게 의미 있는 유일한 결과를 검증하자.
* 예제 코드에서도 결과가 그대로 유지되는 한 정확히 어떻게 생성되는지는 걱정할 필요가 없다.
```kotlin
    @Test
    fun rendering_a_message() {
        val sut = MessageRenderer()
        val message = Message(
            header = "h",
            body = "b",
            footer = "f",
        )
        val html = sut.render(message)

        assertEquals("<h1>h</h1><b>b</b><i>f</i>", html)
    }
```
* 다음의 테스트는 MessageRenderer 를 블랙박스로 취급하고 식별할 수 있는 동작에만 신경 쓴다. 그에 따라 리팩터링 내성이 좋아졌다.
## 4.2 첫 번째 특성(회귀 방지)과 두 번째 특성(리팩터링 내성) 간의 본질적인 관계
* 프로젝트가 시작된 직후에는 회귀 방지가 중요하지만, 리팩터링 내성은 바로 필요 하지 않다.
### 4.2.1 테스트 정확도 극대화
![image](https://user-images.githubusercontent.com/19829583/212478134-ac5f9d51-5b06-4835-b63c-380df2805814.png)
* 테스트의 네 가지 결과
    * 참 음성
        * 테스트가 통과하고 기본 기능이 잘 작동하는 올바른 추론
    * 참 양성
        * 기능이 고장 나서 테스트가 실패하는 올바른 추론
    * 거짓 음성
        * 기능이 고장 났는데도 테스트가 통과하는 경우
        * 회귀 방지가 훌륭한 테스트는 2종 오류인 거짓 음성을 최소화하는 데 도움이 된다.
    * 거짓 양성
        * 기능이 올바르지만 테스트가 여전히 실패하는 경우
        * 허위 경보!
        * 1종 오류인 거짓 양성을 피하는 데 두번째 특성인 리팩터링 내성이 도움이 된다.
* 테스트의 정확도
    * 테스트의 정확도 지표의 두 가지 구성 요소
        * 버그 있음을 얼마나 잘 나타내는가 -> 버그가 있을 때 테스트 결과가 실패일 확률
        * 버그 없음을 얼마나 잘 나타내는가 -> 버그가 없을 때 테스트 결과가 성공일 확률
    * 소음 대비 신호 비율 측면
        * $정확도 = \frac{신호(발견된 버그 수)}{소음(허위 경보 발생 수)}$
        * 테스트 정확도를 향상시키려면? 분자(신호)를 증가시키거나 분모(소음)을 감소시키자!
### 4.2.2 거짓 양성과 거짓 음성의 중요성: 역학 관계
* 프로젝트 초기, 거짓 양성은 버그가 운영 환경에 들어갈 위험을 감수하는 것(거짓 음성)에 비해 별일이 아니다.
  => 리팩터링은 바로 중요하지는 않으며, 시간이 지나면서 중요해지기 때문
* 시간이 지날수록 리팩터링이 필요해지고, 테스트의 리팩터링 내성도 점점 더 중요해진다.
* 기능이 정상인데 테스트가 실패하면 테스트에 대한 신뢰가 떨어진다.
* 대부분의 테스트는 회귀 방지에만 중점을 두는 경향이 있는데, 프로젝트 성장을 유지하는 데는 도움이 되지만 좋은 테스트 스위트를 구축하기에는 충분하지 않다.
* 중대형 프로젝트에서는 거짓 음성(알려지지 않은 버그)과 거짓 양성(허위 경보)에 대해 똑같이 주의를 기울여야 한다.
## 4.3 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성
* 빠른 피드백
    * 테스트 속도가 빠를수록 테스트 스위트에서 더 많은 테스트를 수행할 수 있고 더 자주 실행할 수 있다.
    * 테스트가 빠르게 실행되면 코드에 결함이 생기자마자 버그에 대해 경고하므로, 버그를 수정하는 비용을 거의 0까지 줄일 수 있다.
    * 테스트가 느리면 피드백이 느리고 잠재적으로 버그를 뒤늦게 눈에 띄게 해서 버그 수정 비용이 증가한다.
    * 오래 걸리는 테스트는 자주 실행하지 못하기 때문에 잘못된 방향으로 가면서 시간을 더 많이 낭비하게 된다.
* 유지 보수성: 유지비를 평가한다.
    * 유지비 평가 요소 두 가지
        * 테스트가 얼마나 이해하기 어려운가: 테스트 코드의 라인이 적을수록 읽기 쉽고 변경하기 쉽다.
        * 테스트가 얼마나 실행하기 어려운가: 프로세스 외부 종속성이 있으면 실행 전 DB 서버 재부팅, 네트워크 연결 문제 해결 등의 밑작업이 필요하다.
## 4.4 이상적인 테스트를 찾아서
* 좋은 단위 테스트의 4가지 특성(회귀 방지, 리팩터링 내성, 빠른 피드백, 유지 보수성)을 곱하면 테스트의 가치가 결정된다. 하나라도 0이 되면 전체가 0이 된다.
* 각 특성에 대한 정확한 수치를 얻을 수는 없지만, 각 특성에 대해 평가해서 가치 추정치를 제시할 수는 있다.
* 가치 추정치 = [0..1] * [0..1] * [0..1] * [0..1]
* 가치 추정치의 최소 필수값을 임계치로 정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨라.
### 4.4.1 이상적인 테스트를 만들 수 있는가?
* 처음 세 가지 특성인 회귀 방지, 리팩터링 내성, 빠른 피드백은 트레이드오프 관계여서 세 가지 특성 모두 최대로 하는 것은 불가능하다. 셋 중 하나를 희생해야 나머지 둘을 최대로 할 수 있다.
### 4.4.2 극단적인 사례 1: 엔드 투 엔드 테스트
* 엔드 투 엔드 테스트의 장점
    * 많은 코드를 테스트하므로 회귀 방지를 훌륭히 해낸다.
    * 거짓 양성에 면역이 돼 리팩터링 내성도 우수하다. 최종 사용자의 관점에서 기능이 어떻게 동작하는지만 볼 수 있으며, 구현 세부 사항을 최대한 제거했다.
* 엔드 투 엔드 테스트의 단점
    * 속도가 느리다.
* 테스트 지표
    * 회귀 방지: GOOD!
    * 리팩터링 내성: GOOD!
    * 빠른 피드백: BAD..
### 4.4.3 극단적인 사례 2: 간단한 테스트
* 간단한 테스트 : 너무 단순해서 고장이 없을 것 같은 작은 코드 조각을 테스트하는 것
* 간단한 테스트의 장점
    * 속도가 매우 빠르다.
    * 거짓 양성이 생길 가능성이 상당히 낮다.
* 간단한 테스트의 단점
    * 코드베이스가 너무 간단하여 회귀를 나타내지 않는다. -> 의미가 없는 테스트
    * 항상 통과하거나 검증이 무의미하기 때문에 어떤 것도 테스트한다고 할 수 없다.
* 테스트 지표
    * 회귀 방지: BAD..
    * 리팩터링 내성: GOOD!
    * 빠른 피드백: GOOD!
### 4.4.4 극단적인 사례 3: 깨지기 쉬운 테스트
* 깨지기 쉬운 테스트 : 실행이 빠르고, 회귀를 잡을 가능성이 높지만 거짓 양성이 많은 테스트
* SQL 스크립트 변경 시 SQL 스크립트 비교 테스트는 실패할 수밖에 없음을 예로 들었다. => 테스트가 SUT의 내부 구현 세부 사항에 결합되는 예
* 테스트 지표
    * 회귀 방지: GOOD!
    * 리팩터링 내성: BAD..
    * 빠른 피드백: GOOD!
### 4.4.5 이상적인 테스트를 찾아서: 결론
* 회귀 방지, 리팩터링 내성, 빠른 피드백 모두 완벽한 점수를 얻어서 이상적인 테스트를 만드는 것은 불가능하다.
* 네 번째 특성인 유지 보수성은 엔드 투 엔드 테스트를 제외하고 처음 세 가지 특성과 상관관계가 없다.
    * 엔드 투 엔드 테스트는 관련 의존성 설정 등의 문제로 유지비 측면에서 더 비싸다.
* 네 가지 특성 중 어떤 특성도 0이 되지 않는 식으로 절충이 필요하다.
* 하지만 네 가지 특성 중 리팩터링 내성은 포기할 수 없으므로, 회귀 방지와 빠른 피드백 사이의 절충이 필요하다.
  => 리팩터링 내성은 있거나 없거나 둘 중 하나이므로
* 세 가지 특성과 유사한 관계: 분산 데이터 저장소의 CAP 정리
    * 세 가지 보증
        * 일관성(Consistency): 모든 읽기가 가장 최근의 쓰기 또는 오류를 수신하는 것을 의미한다.
        * 가용성(Availability): 모든 요청이 (시스템 내 전체 노드 중단은 제외하고) 응답을 수신하는 것을 의미한다.
        * 분할 내성(Partition tolerance): 네트워크 분할(네트워크 노드 간 연결 끊김)에도 시스템이 계속 작동함을 의미한다.
    * 테스트 지표와 CAP 정리의 비슷한 점
        * 세 가지 중 두 가지를 선택하는 절충안을 선택해야 한다.
        * 분할 내성도 타협할 수 없으므로, 선택은 일관성과 가용성 간의 절충으로 귀결된다.
## 4.5 대중적인 테스트 자동화 개념 살펴보기
### 4.5.1 테스트 피라미드 분해
![image](https://user-images.githubusercontent.com/19829583/212485758-0f417c6c-e193-4e2a-8d03-33a015ede5d6.png)
* 피라미드 상단의 테스트는 회귀 방지에 유리한 반면, 하단은 실행 속도를 강조한다.
* 어느 계층도 리팩터링 내성은 포기하지 않는다. 모든 테스트는 거짓 양성을 가능한 한 적게 하는 것을 목표로 해야 한다.
* 엔드 투 엔드 테스트의 비중은 전체 프로젝트에서 가장 적어야 한다. 이유는 빠른 피드백 지표에서 매우 낮은 점수를 받고, 유지 보수성이 결여 되어 있기 때문이다.
* 테스트 피라미드의 예외
    * 기타 복잡도가 거의 없는 CRUD 작업: 단위 테스트 $\leq$ 통합테스트, 엔드 투 엔드 테스트 = 0
        * 단위 테스트 : 비즈니스 복잡도가 없는 환경에서는 유용하지 않다.
        * 통합 테스트 : 코드가 아무리 단순해도 DB와 같은 다른 하위 시스템과 잘 통합되어 작동하는지 확인하는 것이 중요하다.
        * 따라서 아주 단순한 예에서는 통합 테스트가 단위 테스트보다 더 많을 수 있다.
    * 프로젝트 외부 의존성 하나(예:데이터베이스)만 연결하는 API: 엔드 투 엔드 테스트
        * 엔드 투 엔드 테스트 : 사용자 인터페이스가 없으므로 엔드 투 엔드 테스트가 상당히 빠르게 실행되며, 단일 외부 의존성으로만 작동하므로 유지비도 크지 않다.
        * 이러한 경우 엔드 투 엔드 테스트와 통합 테스트를 구별하기가 어렵다. 유일한 차이점은, 엔드 투 엔드 테스트에서는 최종 사용자를 애플리케이션 밖에서 호스팅해야 하지만 통합 테스트는 애플리케이션 안에서 모킹한다.
### 4.5.2 블랙박스 테스트와 화이트박스 테스트 간의 선택
* 블랙박스 테스트<sup>black-box testing</sup>: 시스템의 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법. 명세와 요구 사항이 중심.
* 화이트박스 테스트<sup>white-box testing</sup>: 애플리케이션의 내부 작업을 검증하는 테스트 방식. 명세와 요구 사항이 아닌 소스코드에서 테스트가 파생됨.
* 블랙박스 테스트와 비교한 화이트박스 테스트의 장점
    * 테스트가 더 철저하여 외부 명세에만 의존할 때 놓칠 수 있는 많은 오류를 발견할 수 있다.
* 블랙박스 테스트와 비교한 화이트박스 테스트의 단점
    * 테스트 대상 코드의 특정 구현과 결합되어 있기 때문에 깨지기 쉽다.
      => 거짓 양성 많음, 리팩터링 내성 적음, 비즈니스 담당자에게 의미 있는 동작과는 거리가 멀다.

|           |  회귀 방지  | 리팩터링 내성 |
|-----------|:-------:|:---:|
| 화이트박스 테스트 |   좋음    | 나쁨 |
| 블랙박스 테스트  |   나쁨    | 좋음 |

* 리팩터링 내성은 타협할 수 없으므로 화이트박스 테스트보다는 블랙박스 테스트를 기본으로 선택하라.
* 모든 테스트(단위, 통합, 엔드 투 엔드)는 비즈니스적으로 의미 있는 동작을 확인해야 한다. 그렇지 않은 테스트는 재구성하거나 삭제하라.
* 테스트 작성 -> 블랙박스 테스트
* 테스트 분석 -> 화이트박스 테스트 (코드 커버리지 도구로 실행되지 않은 코드 분기를 확인하고 코드 내부 구조에 대해 모르는 것처럼 테스트하라.)

