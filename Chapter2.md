# 2. 단위 테스트란 무엇인가

## 단위 테스트란?

### 단위 테스트

- 작은 코드 조각을 검증
- 빠르게 수행
  - 테스트 스위트의 실행 시간이 충분하다.
- 격리된 방식으로 처리하는 자동화된 테스트
  - 단위 테스트의 고전파와 런던파를 구분하는 차이
  - 런던파는 테스트 대상 시스템을 협력자에게서 격리
    - 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체
    - 테스트가 실패하면 코드베이스의 어느 부분이 고장 났는지 확실히 알 수 있다.
    - 객체 그래프를 분할할 수 있다.
    - 테스트 대상 시스템의 의존성을 테스트 대역으로 대체하면, 테스트 대상 시스템만 검증하는 데 집중할 수 있을 뿐만 아니라 규모가 큰 상호 연결 객체 그래프를 분할할 수 있다.
    - 테스트 대역을 사용하면 객체 그래프를 다시 그리지 않고, 클래스의 직접적인 의존성을 대체하고, 더 나아가 의존성의 의존성을 다룰 필요도 없다.
    - 단순한 테스트 스위트 구조를 만들 수 있다.

일반적인 테스트 3단 구성 : AAA 패턴(Arrange, Act, Assert)
  - 준비 : 의존성과 테스트 대상 시스템을 모두 준비하는 부분
    - 테스트 대상 시스템과 하나의 협력자 준비
  - 실행 : 검증하고자 하는 동작을 수행
  - 검증 : 검증문을 호출하여 동작이 예상 결과로 이어지는지 확인

```java
@Test
public void Purchase_succees_when_enough_inventory() {
  Store store = new Store();
  store.AddInventory(Product.Shampoo, 10);
  Customer customer = new Customer();
  
  bool success = customer.Purchase(store, Product.Shampoo, 5);
  
  Assertions.assertTrue(success);
  Assertions.assertEquals(5, store.GetInventory(Product.Shampoo));
}

public enum Product {
  Shampoo,
  Book
}
```

의존성이 격리 되어 있지 않아 테스트 대상 시스템이 정상이더라도 협력자에 버그가 있으면 단위 테스트 실패

런던파
  - 목 : 테스트 대상 시스템과 협력자 간의 상호 작용을 검사할 수 있는 특별한 테스트 대역
    - 테스트 대역은 실행과 관련 없이 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어
    - 목은 그러한 의존성의 한 종류
      - 협력자에서 격리된 테스트 대상 시스템에는 인터페이스가 필요(구체 클래스도 목으로 만들 수 있지만 안티 패턴)
      - 런던 스타일 : 테스트 대역으로 테스트 대상 코드 조각을 분리해서 격리 요구 사항에 다가간다.

```java
@Test
public void Purchase_succees_when_enough_inventory() {
  Store storeMock = mock(IStore.class);
  when(storeMock.HasEnoughInventory(Product.Shampoo, 5)).thenReturn(true)
  Customer customer = new Customer();
  
  bool success = customer.Purchase(store, Product.Shampoo, 5);
  
  Assertions.assertTrue(success);
  verify(storeMock).HasEnoughInventory();
}

public enum Product {
  Shampoo,
  Book
}
```

## 공유 의존성, 비공개 의존성, 휘발성 의존성 간의 차이점

### 격리 특성에 대한 고전적인 해석

- 단위 테스트는 서로 격리해서 실행해야 한다.
- 테스트를 어떤 순서로든 실행할 수 있고 서로의 결과에 영향을 미치지 않는다.
- 여러 클래스가 모두 메모리에 상주하고 공유 상태에 있지 않는 한, 여러 클래스를 한 번에 테스트해도 괜찮다.
- 테스트가 서로 소통하고 실행 컨텍스트에 영향을 줄 수 있다.
    - 데이터베이스, 파일 시스템 등 프로세스 외부 의존성이 공유 상태의 대표적인 예
- 테스트 대역을 사용할 수 있지만, 보통 테스트 간에 공유 상태를 일으키는 의존성에 대해서만 사용

### 공유 의존성, 비공개 의존성, 프로세스 외부 의존성

- 공유 의존성 : 테스트 간에 공유 되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성
    - 정적 가변 필드, 데이터베이스
    - 이러한 필드의 변경 사항은 동일한 프로세스 내에 실행되는 모든 단위 테스트에서 볼 수 있어 영향을 끼친다
- 비공개 의존성 : 공유하지 않는 의존성
- 프로세스 외부 의존성 : 애플리케이션 실행 프로세스 외부에서 실행 되는 의존성
    - 아직 메모리에 없는 데이터에 대한 프록시
    - 대부분 공유 의존성이지만 아닌 것도 있다.
    - 데이터베이스는 프로세스 외부 의존성이면서 공유 의존성
    - 도커로 데이터베이스를 시작하는 경우 프로세스 외부 의존성이지만 공유 의존성은 아니다

- 단위 테스트를 서로 격리하는 것은 테스트 대상 클래스에서 공유 의존성만 격리하는 것을 의미. 비공개 의존성은 그대로 둘 수 있다.
- 공유 의존성은 테스트 대상 클래스 간이 아니라 단위 테스트 간에 공유
- 공유 의존성을 대체하는 또 다른 이유 : 테스트 실행 속도를 높이기 위해
    - 공유 의존성은 거의 항상 실행 프로세스 외부에 있는 데 반해, 비공개 의존성은 보통 그 경계를 넘지 않는다.
    - 데이터베이스나 파일 시스템 등의 공유 의존성에 대한 호출은 비공개 의존성에 대한 호출보다 오래 걸리므로 단위 테스트 영역에서 통합 테스트 영역으로 넘어감
- 공유 의존성과 휘발성 의존성 간의 차이점
    - 휘발성 의존성
        - 개발자 머신에 기본 설치된 환경 외에 런타임 환경의 설정 및 구성을 요구
            - 예) 데이터베이스, API 서비스
        - 비결정적 동작을 포함
            - 난수 생성기 또는 현재 날짜와 시간을 반환하는 클래스

## 단위 테스트의 두 분파 : 고전파와 런던파

- 고전파 : 모든 사람이 단위 테스트와 테스트 주도 개발에 원론적으로 접근하는 방식
- 런던파 : 런던의 프로그래밍 커뮤니티에서 시작

고전파와 런던파가 나눠진 원인 : 격리 특성
- 격리 요구 사항
- 테스트 대상 코드 조각의 구성 요소
- 의존성 처리

|  | 격리 주체 | 단위의 크기 | 테스트 대역 사용 대상 |
| --- | --- | --- | --- |
| 런던파 | 단위 | 단일 클래스 | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성 |

런던파

- 테스트 대상 시스템에서 협력자를 격리
- 테스트에서 일부 의존성을 그대로 사용할 수 있다. 즉, 불변 객체는 교체하지 않아도 된다.
- 변경 가능한 한 비공개 의존성도 테스트 대역으로 교체

고전파

- 단위 테스트끼리 격리
- 공유 의존성을 테스트 대역으로 교체

공유 의존성과 프로세스 외부 의존성 간의 관계

- 공유 의존성이면서 프로세스 외부 의존성이 아닌 것 : 싱글톤
- 공유 의존성이면서 프로세스 외부 의존성인 것 : 데이터베이스
- 공유 의존성이 아니면서 프로세스 외부 의존성인 것 : 읽기 전용 API 서비스

런던파의 장점
- 입자성이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인한다.
    - 테스트가 단일 동작 단위를 검증하는 한 좋은 테스트
- 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다. 모든 협력자는 테스트 대역으로 대체 되기 때문에 테스트 작성 시 걱정할 필요가 없다.
    - 실제 협력자를 대신 목을 사용하면 클래스를 쉽게 테스트 할 수 있다.
    - 테스트 대역을 쓰면 클래스의 직접적인 의존성을 대체해 그래프를 나눌 수 있다.
    - 그 전에 이러한 클래스 그래프를 갖지 않도록 해야 한다. 클래스 그래프가 커진 것은 대부분 코드 설계의 문제이다.
- 테스트가 실패하면 어떤 기능이 실패 했는지 확실하게 알 수 있다.
    - 테스트가 실패하면 보통 SUT에 버그가 포함된 테스트만 실패한다.

### 고전파와 런던파 사이의 다른 차이점
- 테스트 주도 개발을 통한 시스템 설계 방식
    - 테스트 주도 개발 : 테스트에 의존해 프로젝트 개발을 추진하는 소프트웨어 개발 프로세스
        - 추가해야 할 기능과 어떻게 동작해야 하는지를 나타내는 실패 테스트 작성
        - 테스트가 통과할 만큼 충분히 코드를 작성
        - 코드를 리팩터링
    - 런던파는 목을 활용할 수 있기 때문에 하향식으로 설계
    - 고전파는 테스트에서 실제 객체를 다뤄야 하기 때문에 일반적으로 상향식으로 설계
- 과도한 명세 문제 : 테스트가 SUT의 구현 세부 사항에 결합 됨
    - 런던 스타일은 테스트가 구현에 더 자주 결합 됨

## 단위 테스트, 통합 테스트, 엔드 투 엔드 테스트의 차이점

- 단위 테스트
    - 작은 코드 조각을 검증
    - 빠르게 테스트 수행
    - 격리된 방식으로 처리
- 통합 테스트
    - 공유 의존성, 프로세스 외부 의존성뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트
    - 단위 테스트 기준 중 하나를 충족하지 않는 테스트
        - 두 개 이상의 동작 단위를 검증
        - 프로세스 외부 의존성에 접근
        - 공유 의존성에 접근
- 엔드 투 엔드 테스트
    - 통합 테스트의 일부
    - 일반적으로 통합 테스트보다 의존성을 더 많이 포함
        - 통합 테스트는 프로세스 외부 의존성을 한 두개만 가짐
        - 엔드 투 엔드 테스트는 의존성 전부 또는 대다수를 가짐
    - 모든 외부 어플리케이션을 포함한 시스템을 최종 사용자의 관점에서 검증
    - UI 테스트, GUI 테스트, 기능 테스트 라고도 함
    - 유지 보수 측면에서 가장 많은 비용이 들기 때문에 모든 단위 테스트와 통합 테스트를 통과한 후 빌드 프로세스 후반에 실행하는 것이 좋다.

- 런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주
    - 고전파 스타일로 작성된 대부분의 테스트는 런던파 지지자들에게 통합 테스트로 느껴짐
