# 단위 테스트란 무엇인가

## 단위 테스트의 정의
- 작은 코드 조각(단위) 를 검증하고
- 빠르게 수행하고
- 격리된 방식으로 처리하는 자동화된 테스트
	- '격리'는 고전파와 런던파를 구분하는 근원적 차이

### 격리 문제에 대한 런던파의 접근
- 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체
	- 장점
		- 테스트가 실패하면 어느 부분이 고장 났는지 확실히 알 수 있음
		- 객체 그래프를 분해해서 단위테스트 준비를 줄일 수 있음
			- 즉, 의존성을 쉽게 대체할 수 있음
		- 한번에 한 클래스만 테스트하라는 지침을 도입하면 전체 단위 테스트 스위트를 간단한 구조로 할 수 있음

### 고전파 테스트 코드 예시
![](attachments/스크린샷%202023-03-26%20오후%209.45.38.png)
- 테스트 대상 시스템(System Under Test)
	- Customer
- 협력자
	- Store
- 협력자를 stub 으로 대체하지 않고 운영용 인스턴스를 사용. 즉, Customer 와 Store 는 서로 격리되어 있지 않음

### 런던파 테스트 코드 예시
![](attachments/스크린샷%202023-03-26%20오후%209.48.24.png)![](attachments/스크린샷%202023-03-26%20오후%209.48.35.png)
- `Store` 는 실제 인스턴스를 생성하지 않고 Mock 을 사용해 대체
	- 협력자를 mocking 할 때 인터페이스가 필요하다는 점에 유의. (chpt11)
- `customer` - `store` 간 상호작용 검사. 즉, 호출이 올바르게 이뤄졌는지 확인


### 격리 문제에 대한 고전파의 접근
- 런던파
	- 일반적으로 한 번에 한 클래스로 테스트하는 것을 권장.
- 고전파
	- '코드' 보다는 unit test 별로 격리해서 실행하는 것을 권장

#### Shared dependency
- 테스트 간에 공유됨
- 테스트끼리 서로의 결과에 영향을 미칠 수 있는 의존성
- e.g. static mutable field
#### private dependency
- 테스트 간 공유되지 않는 의존성
#### out-of-process dependency
- 어플리케이션 프로세스 외부에서 실행되는 의존성
- (참고) 모든 out-of-process dependency 가 곧 shared depedency 인 것은 아님. e.g. 읽기 전용 API 서비스 : out-of-process dependency && private depedency

- 고전파에서는 테스트 간에 공유 상태를 일으키는 의존성에 대해서만 stub 을 사용.
	- '단위' 를 구성할 때 클래스에 국한될 필요 없음. 공유 의존성이 없는 한 여러 클래스를 묶어서 단위 테스트 가능

![](attachments/스크린샷%202023-03-26%20오후%2010.04.01.png)

- (참고) 싱글턴 의존성, 설정 클래스는 제품 코드 상에서는 하나를 만들어서 공유해서 사용하지만 테스트에서는 테스트마다 인스턴스를 만들어서 사용할 수 있기 때문에 private dependency 에 해당

- 공유 의존성 대체 장점
	- 테스트 실행 속도 빨라짐


## 단위 테스트의 런던파와 고전파
![](attachments/스크린샷%202023-03-26%20오후%2010.11.14.png)
- 차이점
	- 격리 주체
	- 단위 크기
	- 테스트 대역 사용 대상
		- 공통적으로 불변 객체는 대역 사용하지 않아도 됨
		- e.g. 예시 코드에서 `Product`

![](attachments/스크린샷%202023-03-26%20오후%2010.15.37.png)
- 대역 사용 대상 차이
	- 고전파
		- Shared dependency only
	- 런던파
		- Shared dependency + Mutable private dependency(e.g. `Store` instance)
- 협력자
	- shared or Mutable dependency
## 고전파와 런던파의 비교
### 런던파 장점 (뽀개기)
- 한 번에 한 클래스만 테스트
	- 클래스 == unit
	- but, 테스트는 단일 동작 단위를 검증한다면 좋은 테스트. 즉, 코드 입자성을 목표로 하는 것은 좋은 테스트와는 관련 X
	- e.g.`우리집 강아지를 부르면 바로 나에게 온다` 검증
- 연결된 클래스의 그래프가 커져도 테스트하기 쉬움.
	- 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 만들지 않는 것에 집중해야 함.
	- Mock 은 이 문제를 감추기만 할 뿐. 따라서 장점으로 보기 어려움
- 테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있음
	- 테스트를 정기적으로(코드가 바뀔 때마다) 실행하면 고전파 방식으로도 테스트 실패 원인을 쉽게 파악할 수 있음


## 고전파와 런던 사이의 또 다른 차이점
- TDD 방식
	- 런던파
		- outside-in TDD
			- 상위 레벨 테스트부터 시작해서 Mock 을 지정하는 방식으로 진행
	- 고전파
		- inside-out TDD
			- domain model 에서부터 시작해서 layer 를 하나씩 추가하는 방식으로 진행
- over specification 문제
	- test - 구현 세부사항 강결합
	- 런던파는 고전파에 비해 구현에 강결합된 테스트를 생성하는 경향이 있음.
		- 런던파의 치명적인 문제점
		- Q. 테스트와 구현 코드가 강결합 된다는 것이 어떤 의미인지 모르겠다.
			- e.g. Mockito when().doReturn() 을 일일이 설정해줘야 함.


## 두 분파의 통합 테스트
- 런던파
	- 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주
	- e.g. 위 고전파가 작성한 Customer - Store 테스트 또한 런던파 입장에서는 통합 테스트에 해당
- 고전파 관점에서 통합 테스트 - 단위 테스트 차이
	- 통합 테스트
		- 공유 의존성에 접근하는 테스트는 다른 테스트와 격리된 채 수행될 수 없음. -> Q. 잘 이해가 안 된다... 말그대로 공유하는 상태가 있기 때문에 격리시킬 수 없다는 뜻인가?
		- 프로세스 외부 의존성에 접근하기 때문에 테스트가 느려짐
		- 둘 이상의 동작 단위 검증
- (참고) end to end test
	- 모든 외부 어플리케이션을 포함해 시스템을 최종 사용자의 관점에서 검증하는 것.

---
- 통합테스트
	- 테스트 DB 로 실제로 연결해서 진행하는 사례도 있음
	- 